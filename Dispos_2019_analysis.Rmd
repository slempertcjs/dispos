---
title: "Dispos_2019_analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

# Libraries
```{r include=FALSE}
library(gsubfn)
library(lubridate)
library(openxlsx)
library(data.table)
library(lubridate)
library(readxl)
library(fuzzyjoin)
library(tidyverse)
library(tools)
library(vroom)
library(beepr)
library(sandwich) # for robust standard errors
library(lmtest) # to run tests using the robust standard errors
library(broom) # to get stuff out of the objects lmtest produces
#library(blorr) #for pseudo R2 and other analytics
library(pscl) #package for pseudo R2 (pR2 function)
library(RColorBrewer)

```

# Clean and collapse ACHS data

Import sample data
```{r}
#df <- fread("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw Doj Data 2019.csv", colClasses = "character", header = T)

#df <- read.csv("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw Doj Data 2019.csv", colClasses = "character", header = T)

#top_doj <- read.csv(files[1], colClasses = "character", header = T)

#dsam <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw Doj Data 2019.csv", n_max = 1000, col_types = c(.default = "c"))

dsam <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw DOJ Data 2019-Empty Variables Removed.csv", n_max = 10000, col_types = c(.default = "c"))


#obts <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/DALA_2019_JCC.csv")
```

Diagnostic code using the full dataset isolating columns of interest
```{r}
# allsubs <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw DOJ Data 2019-Empty Variables Removed.csv",
#                  col_select = c(SUBJECT_ID),
#                  #n_max = 100000,
#                  col_types = c(.default = "c"))

#figure out break points for chunking so that no subjects are broken into multiple chunks
# allsubs <- allsubs %>%
#   arrange(SUBJECT_ID)

# distinct_subs <- allsubs %>%
#   distinct(SUBJECT_ID)
# 93,920 distinct subjects

# alloff <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw DOJ Data 2019-Empty Variables Removed.csv",
#                  col_select = c(OFFENSE_DESCR, OFFENSE_TOC),
#                  #n_max = 100000,
#                  col_types = c(.default = "c"))

# offenses <- alloff %>%
#   count(OFFENSE_DESCR, OFFENSE_TOC)

#save(offenses, file = "All offenses in full 2019 file_SL.RData")

#fwrite(offenses, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/All offenses by frequency in ACHS.csv")

# load("All offenses in full 2019 file_SL.RData")
# load("G:/CrimJustice/PretrialAssessmentPilot/Complete Charge Code Hierarchy_SL.RData")

# all_offenses_with_hierarchy <- offenses %>%
#   mutate(offense_orig = str_extract(OFFENSE_DESCR, "^.*\\-"),
#          offense_stat = str_extract(offense_orig, " .*"),
#          offense_stat = gsub(" |-.*", "", offense_stat),
#          offense_orig = gsub(" .*", "", offense_orig),
#          offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
#   unite(join_var, OFFENSE_TOC, offense_stat, offense, remove = F, na.rm = T) %>%
#   inner_join(charge_hier, by = "join_var") %>%
#   arrange(desc(n))

#save(all_offenses_with_hierarchy, file = "All offenses with hierarchy in full 2019 file_SL.RData")
#fwrite(all_offenses_with_hierarchy, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/All offenses with hierarchy by frequency in ACHS.csv")


# load("G:/CrimJustice/PretrialAssessmentPilot/Complete Charge Code Hierarchy_SL.RData")


# summary_missing_offenses <- offenses %>%
#   mutate(offense_orig = str_extract(OFFENSE_DESCR, "^.*\\-"),
#          offense_stat = str_extract(offense_orig, " .*"),
#          offense_stat = gsub(" |-.*", "", offense_stat),
#          offense_orig = gsub(" .*", "", offense_orig),
#          offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
#   unite(join_var, OFFENSE_TOC, offense_stat, offense, remove = F, na.rm = T) %>%
#   inner_join(charge_hier, by = "join_var") %>%
#   filter(summary_code == 1000) %>%
#   arrange(desc(n))
# 
# fwrite(summary_missing_offenses, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Offenses missing summary codes by frequency in ACHS.csv")

# nonmatching_offenses <- offenses %>%
#   mutate(offense_orig = str_extract(OFFENSE_DESCR, "^.*\\-"),
#          offense_stat = str_extract(offense_orig, " .*"),
#          offense_stat = gsub(" |-.*", "", offense_stat),
#          offense_orig = gsub(" .*", "", offense_orig),
#          offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
#   unite(join_var, OFFENSE_TOC, offense_stat, offense, remove = F, na.rm = T) %>%
#   anti_join(charge_hier, by = "join_var") %>%
#   arrange(desc(n))
# 
# fwrite(nonmatching_offenses, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Offenses not matching charge hierarchy by frequency in ACHS.csv")

#Only 14,515 matched charges missing summary codes out of... a lot. In the analysis code I fix the two most common ones (ones with >1000 rows), which leaves only 3,774 matched charges missing summary codes.
#summary_missing_offenses 

#charges with >1000 rows that are missing summary codes:
# F_PC_487 -- Grand theft . Should have summary code 09 for felony theft
# M_PC_484A4905 -- 484(A)/490.5 Theft/petty theft merchandise. Should have summary code 31 for misdemeanor petty theft



# this version was looking at jbsis codes

# longsam <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw DOJ Data 2019-Empty Variables Removed.csv",
#                  col_select = c(SUBJECT_ID, CYC_DATE, OFFENSE_DESCR, OFFENSE_TOC),
#                  #n_max = 100000,
#                  col_types = c(.default = "c"))
# beep(4)
# 
# subjs <- longsam %>%
#   distinct(SUBJECT_ID)
# 
# offenses <- longsam %>%
#   count(OFFENSE_DESCR, OFFENSE_TOC)
# 
# yr_ct <- longsam %>%
#   mutate(CYC_DATE = as_date(CYC_DATE)) %>%
#   count(year(CYC_DATE)) 

# long_subcyc <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Raw DOJ Data 2019-Empty Variables Removed.csv",
#                  col_select = c(SUBJECT_ID, CYC_DATE),
#                  #n_max = 100000,
#                  col_types = c(.default = "c"))
# beep(4)

# subcyc <- long_subcyc %>%
#   mutate(CYC_DATE = as_date(CYC_DATE)) %>%
#   distinct(SUBJECT_ID, CYC_DATE)

#1,773,653 unique subject/cyc_date combinations

# beep(4)  # beep 4 is "work complete". beep 9 would make a good error noise. beep 10 is pleasantly short.

#names(yr_ct) <- c("year", "n")

# yr_ct %>%
#   arrange(desc(year))

# load("G:/CrimJustice/PretrialAssessmentPilot/Complete Charge Code Hierarchy.RData")
# 
# 
# jbsis_missing_offenses <- offenses %>%
#   mutate(offense_orig = str_extract(OFFENSE_DESCR, "^.*\\-"),
#          offense_stat = str_extract(offense_orig, " .*"),
#          offense_stat = gsub(" |-.*", "", offense_stat),
#          offense_orig = gsub(" .*", "", offense_orig),
#          offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
#   unite(join_var, OFFENSE_TOC, offense_stat, offense, remove = F, na.rm = T) %>%
#   inner_join(charge_hier, by = "join_var") %>%
#   filter(jbsis_code == 1000) %>%
#   arrange(desc(n))
# 
# fwrite(jbsis_missing_offenses, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Offenses missing JBSIS codes by frequency in ACHS.csv")

# nonmatching_offenses <- offenses %>%
#   mutate(offense_orig = str_extract(OFFENSE_DESCR, "^.*\\-"),
#          offense_stat = str_extract(offense_orig, " .*"),
#          offense_stat = gsub(" |-.*", "", offense_stat),
#          offense_orig = gsub(" .*", "", offense_orig),
#          offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
#   unite(join_var, OFFENSE_TOC, offense_stat, offense, remove = F, na.rm = T) %>%
#   anti_join(charge_hier, by = "join_var") %>%
#   arrange(desc(n))

#fwrite(nonmatching_offenses, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Offenses not matching charge hierarchy by frequency in ACHS.csv")


```

Clean and standardize data
```{r}
names(dsam) <- tolower(names(dsam))

dsam <- dsam %>%
  mutate(across(contains("date"),ymd)) %>%
  mutate(offense_orig = str_extract(offense_descr, "^.*\\-"),
         offense_stat = str_extract(offense_orig, " .*"),
         offense_stat = gsub(" |-.*", "", offense_stat),
         offense_orig = gsub(" .*", "", offense_orig),
         offense = toupper(gsub("\\/|\\(|\\)| |\\.|\\.*|^[A-Z]*|\\\\.*|\\{|\\}","", offense_orig))) %>%
  unite(join_var, offense_toc, offense_stat, offense, remove = F, na.rm = T)



#Filter stp_type_descr to just -- ASK WHAT ALL THE REST MEAN -- is there any reason to keep the others? look into cases that were expunged? any other post-disposition actions that would be relevant? look into what the additional arrest action steps are.
#
dsam <- dsam %>%
  filter(stp_type_descr %in% c("ARREST/DETAINED/CITED", "COURT ACTION"))

#Identify steps with final dispositions. Look at disp_descr to identify dispositions that are not final dispositions (e.g. bench warrant, bail forfeit)

# dsam <- dsam %>%
#   mutate(final_disp = if_else())

#Use step event date as dispo date when there is a disposition but no dispo date (this is all court dispositions and some arrest dispositions)
## step event date is missing for all step types descriptions that are "Additional action" (arrest, court, or custody level) -- unclear what dispositions mean for these
dsam <- dsam %>%
  mutate(dispo_date = case_when(!is.na(disp_date) ~ disp_date,
                                !is.na(disp_descr) ~ stp_event_date),
         arrest_disp = if_else(!is.na(disp_descr) & stp_ori_type_descr == "Arrest", 1, 0),
         court_disp = if_else(!is.na(disp_descr) & stp_ori_type_descr == "Court", 1, 0))

#Remove variables that are not useful
## what are single_source and multi_source?
dsam <- dsam %>%
  select(-c(subject_status, req_gender, race_descr, eye_color_code, eye_color_descr, hair_color_code, hair_color_descr, height, weight, 
            single_source, multi_source, pob_code, pob_name, pob_type,
            conv_offense_order, conv_offense_code, conv_offense_descr, conv_offense_toc, conv_offense_qual_lst, #conv_offense variables are almost never filled out
            disp_offense_code, disp_offense_descr, disp_offense_toc, disp_offense_qual_lst, #disp_offense variables are almost never filled out
            stp_ori_code, stp_ori_descr, stp_ori_cnty_code, stp_ori_type, sent_time_code, sent_loc_code)) %>%  #ori not necessary. ori type, county, sent time, sent loc have additional descriptor variables
  mutate(citizen = case_when(is.na(citizenship_list) ~ NA_real_,
                             grepl("US", citizenship_list) ~ 1,
                             T ~ 0)) %>%
  select(-citizenship_list)


#standardize sentence length
## what does it mean when sentence location is unknown?
## suspended or stayed sentences turn into probation -- how should these be counted? Ask Alexis. Sometimes "JAIL SS", sometimes "IMP SEN SS", sometimes there is both a jail and a suspended jail sentence, does that mean they imposed one and suspended the other?
dsam <- dsam %>%
  mutate(sent_length = as.numeric(sent_length)) %>%
  mutate(sent_length_days = case_when(sent_time_descr == "HOURS" ~ round(sent_length/24),
                                      sent_time_descr == "DAYS" ~ sent_length,
                                      sent_time_descr == "WEEKENDS" ~ sent_length*2,
                                      sent_time_descr == "MONTHS" ~ round(sent_length*365.25/12),
                                      sent_time_descr %in% c("YEARS", "YEARS TO LIFE") ~ round(sent_length*365.25),
                                      sent_length == 0 ~ 0)) %>%
  mutate(sent_life_flag = if_else(grepl("LIFE", sent_time_descr), 1, 0)) %>%
  mutate(sent_prison_flag = if_else(sent_loc_descr %in% c("PRISON", "TOT FIX PRS TRM"), 1, 0),
         sent_jail_flag = if_else(sent_loc_descr %in% c("JAIL", "JAIL OR FINE"), 1, 0),
         sent_probation_flag = if_else(sent_loc_descr %in% c("PROBATION"), 1, 0),
         sent_ex_suspended_flag = if_else(sent_loc_descr %in% c("JAIL SS", "PRISON SS", "PRISON STAYED", "JAIL SS COND", "JAIL OR FINE SS", "FINE SS"), 1, 0),
         sent_imp_suspended_flag = if_else(sent_loc_descr %in% c("IMP SEN SS" ,"SEN SS", "STAYED"), 1, 0),
         sent_concurrent_flag = if_else(sent_loc_descr %in% c("CONCURRENT"), 1, 0))
## for the collapse, will need to cancel out the jail or prison flag and add a probation flag if there is a imp_suspended_flag. Will need to add times unless there is a concurrent_flag.


```

Join charge hierarchy and add prefixes to charge flags
```{r}

#Load complete charge hierarchy with flags that have been worked on by lawyers, version where I kept the summary codes
load("G:/CrimJustice/PretrialAssessmentPilot/Complete Charge Code Hierarchy_SL.RData")

#Add summary codes for the two most common offenses that are missing them
#charges with >1000 rows that are missing summary codes:
# F_PC_487 -- Grand theft . Should have summary code 09 for felony theft
# M_PC_484A4905 -- 484(A)/490.5 Theft/petty theft merchandise. Should have summary code 31 for misdemeanor petty theft
#This is now unnecessary because it was moved to the code that creates the charge hierarchy so the version loaded in will already be fixed
# charge_hier <- charge_hier %>%
#   mutate(summary_code = if_else(join_var %in% c("F_PC_487"), 9, summary_code),
#          summary_code = if_else(join_var %in% c("M_PC_484A4905"), 31, summary_code))

#Add flags for offense types based on DOJ summary codes

charge_hier <- charge_hier %>%
  select(-c(property_flag, drug_flag)) %>%
  mutate(summ_f_violent_flag = if_else(summary_code %in% c(1:7), 1, 0),
         summ_f_property_flag = if_else(summary_code %in% c(8:11, 24), 1, 0),
         summ_f_drug_flag = if_else(summary_code %in% c(12:15), 1, 0),
         summ_f_other_sex_flag = if_else(summary_code %in% c(16:18), 1, 0),
         summ_f_other_flag = if_else(summary_code %in% c(19:23, 25:28), 1, 0),
         summ_m_violent_flag = if_else(summary_code %in% c(29:30), 1, 0),
         summ_m_property_flag = if_else(summary_code %in% c(31:33, 64), 1, 0),
         summ_m_drug_flag = if_else(summary_code %in% c(34:36), 1, 0),
         summ_m_other_sex_flag = if_else(summary_code %in% c(37:41), 1, 0),
         summ_m_other_flag = if_else(summary_code %in% c(42:63, 65:67, 74, 76), 1, 0),
         summ_status_flag = if_else(summary_code %in% c(68:72), 1, 0))


# ## add JBSIS codes to the two most common Infractions that are missing them
# charge_hier <- charge_hier %>%
#   mutate(jbsis_code = if_else(join_var %in% c("I_VC_4000A", "I_VC_16028A"), 290, jbsis_code))
# 
# ## add JBSIS category flags that are not already captured in the hierarchy
#   ## already in the hierarchy: property_flag, drug_flag. remove these to create misdo/fel specific jbsis flags
# charge_hier <- charge_hier %>%
#   select(-c(property_flag, drug_flag)) %>%
#   mutate(jbsis_m_property_flag = if_else(jbsis_code %in% c(220), 1, 0),
#          jbsis_m_drug_flag = if_else(jbsis_code %in% c(230), 1, 0),
#          jbsis_m_violent_flag = if_else(jbsis_code %in% c(210), 1, 0),
#          jbsis_m_sex_flag = if_else(jbsis_code %in% c(240), 1, 0),
#          jbsis_m_other_flag = if_else(jbsis_code %in% c(250, 260), 1, 0),
#          jbsis_traffic_flag = if_else(jbsis_code %in% c(270, 280, 290), 1, 0),
#          jbsis_f_property_flag = if_else(jbsis_code %in% c(70), 1, 0),
#          jbsis_f_drug_flag = if_else(jbsis_code %in% c(80), 1, 0),
#          jbsis_f_violent_flag = if_else(jbsis_code %in% c(10, 20, 30, 40, 50), 1, 0),
#          jbsis_f_sex_flag = if_else(jbsis_code %in% c(60), 1, 0),
#          jbsis_f_other_flag = if_else(jbsis_code %in% c(90), 1, 0))
# 



dsam <- left_join(dsam, charge_hier, by = "join_var")
      
# Add prefixes to charge flags
dsam <- dsam %>%
  mutate(felony_flag = if_else(offense_toc == "F", 1, 0),
         misd_flag = if_else(offense_toc == "M", 1, 0),
         inf_flag = if_else(offense_toc == "I", 1, 0)) %>%
  mutate_at(vars(contains("flag"), -contains("sent")), funs("arrest" = if_else(. == 1 & stp_type_descr == "ARREST/DETAINED/CITED", 1, 0))) %>%
  mutate_at(vars(c(contains("flag"), -contains("sent"), -contains("_arrest"))), funs("court" = if_else(. == 1 & stp_type_descr == "COURT ACTION", 1, 0))) %>%
  mutate_at(vars(c(contains("flag"), -contains("sent"), -contains("_arrest"), -contains("_court"))), funs("conviction" = if_else(. == 1 & grepl("CONVICTED", disp_descr), 1, 0))) %>%
  rename_at(vars(contains("_conviction")), funs(paste0("conviction_", gsub("_conviction", "", .)))) %>%
  rename_at(vars(contains("_arrest")), funs(paste0("arrest_", gsub("_arrest", "", .)))) %>%
  rename_at(vars(contains("_court")), funs(paste0("court_", gsub("_court", "", .))))

#remove the flags without prefixes
dsam <- dsam %>%
  select(!(serious_felony_flag:inf_flag))


```

Diagnostic code
```{r}

# charge_hier %>%
#   mutate(jbsis = jbsis_m_property_flag + jbsis_m_drug_flag + jbsis_m_violent_flag + jbsis_m_sex_flag + jbsis_m_other_flag + jbsis_traffic_flag + jbsis_f_property_flag + jbsis_f_drug_flag + jbsis_f_violent_flag + jbsis_f_sex_flag+ jbsis_f_other_flag) %>%
#   filter(jbsis == 1)


# dsam %>%
#   filter(arrest_disp ==1) %>%
#   count(disp_descr) %>%
#   arrange(desc(n))
# 
# 
# dsam %>%
#   filter(sent_time_descr == "Unknown" & !is.na(sent_length)) %>%
#   select(contains("sent_"))
# 
# dsam %>%
#   filter(!is.na(sent_length)) %>%
#   count(sent_time_descr)
#   select(contains("sent_"))
# 
# dsam %>%
#   filter(!is.na(sent_length))%>%
#   select(contains("sent_"))
# 
# dsam %>%
#   filter(!is.na(sent_time_descr) & sent_time_descr != "Unknown") %>%
#   filter(is.na(sent_length)) %>%
#   select(contains("sent"))
# 
# dsam %>%
#   filter(!is.na(sent_loc_descr)) %>%
#   select(sent_order, sent_loc_descr, sent_length, sent_time_descr)
# 
# dsam %>%
#   count(sent_order) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   distinct(subject_id, cyc_order, .keep_all = T) %>%
#   add_count(subject_id, cyc_date) %>%
#   filter(n>1)
# 
# dsam %>%
#   filter(!is.na(disp_order)) %>%
#   group_by(subject_id, cyc_date, cnt_order) %>%
#   mutate(n = length(unique(disp_order)),
#          ns = length(unique(sent_order))) %>%
#   ungroup() %>%
#   filter(n>1 & ns>1) 
# 
# dsam %>%
#   count(stp_type_descr) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   #filter(!is.na(disp_order)) %>%
#   group_by(subject_id, cyc_date) %>%
#   #mutate(disp_count = length(unique(str_extract(disp_order, "...$")))) %>%
#   #add_count(disp_order) %>%
#   #filter(disp_count >1) %>%
#   #filter(!is.na(sent_order))
#   mutate(across(c(contains("_flag")), max),
#          jail_count = sum(sent_jail_flag),
#          prison_count = sum(sent_prison_flag),
#          prob_count = sum(sent_probation_flag),
#          imp_count = sum(sent_imp_suspended_flag)) %>%
#   #mutate(disp_count = count(disp_order)) %>%
#   #distinct(subject_id, cyc_date, .keep_all = T) %>%
#   #count(sent_prison_flag, prison_count, sent_jail_flag, jail_count, sent_probation_flag, prob_count, sent_ex_suspended_flag, sent_imp_suspended_flag, imp_count) %>%
#   #arrange(desc(n)) %>%
#   ungroup() %>%
#   filter(imp_count >0) %>%
#   filter(imp_count < prison_count + jail_count) %>%
#   select(subject_id, cyc_date, disp_order, sent_order, sent_loc_descr, sent_length, sent_time_descr, sent_prison_flag, prison_count, sent_jail_flag, jail_count, sent_probation_flag, prob_count, sent_ex_suspended_flag, sent_imp_suspended_flag, imp_count)
# 
# 
# charge_hier %>%
#   filter(jbsis_code == 1000)
```

Collapse each cycle (first version that was run January 2021, using cycle date)
```{r}
# 
# ## 
# 
# suppressWarnings(
# coll_df <- dsam %>%
# 
#   mutate(arrested_flag = if_else(grepl("Arrest", stp_ori_type_descr), 1, 0),
#          filed_flag = if_else(grepl("Court", stp_ori_type_descr), 1, 0),
#          convicted_flag =  if_else(grepl("^CONVICTED", disp_descr), 1, 0),
#          dismissed_flag = if_else(grepl("DISCH|ACQUIT|DISMISSED|REL|REJ", disp_descr), 1, 0)) %>% 
#   
#   mutate(across(contains("flag"), ~if_else(is.na(.x), 0, .x))) %>%
#  
#   mutate(hierarchy = if_else(is.na(hierarchy) | hierarchy == "0", 1e6, as.numeric(hierarchy))) %>%
#   mutate(sentence_date = if_else(!is.na(sent_order), stp_event_date, as_date(NA_character_))) %>%
#   
#   ##adjust sentence indicators to account for suspended sentences
#   ## first deal with within each count to cancel out suspended jail/prison sentences
#   group_by(subject_id, cyc_date, cnt_order) %>%
#   
#   mutate(sent_ex_suspended_flag = max(sent_ex_suspended_flag),
#          sent_imp_suspended_flag = max(sent_imp_suspended_flag),
#          sent_prison_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_prison_flag),
#          sent_jail_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_jail_flag)) %>%
#   
#   group_by(subject_id, cyc_date) %>%
#   
#   #how should concurrent sentences be treated? looked at instances, and appears to be used inconsistently, sometimes when there is no other sentence for it to be concurrent with. could do max instead of sum when there is a concurrent flag, but in cases with more than 2 sentences this may not be correct. probably best to leave as is. 
#   mutate(prison_length_days = sum(sent_length_days[sent_prison_flag == 1]),
#          jail_length_days = sum(sent_length_days[sent_jail_flag == 1]),
#          probation_length_days = sum(sent_length_days[sent_probation_flag == 1]),
#          #probation length will be incorrect in cases where there is a suspended sentence with no probation term specified
#          sent_probation_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag == 1, 1, max(sent_probation_flag))) %>%
#   mutate(across(matches("sent_.*_flag"), max)) %>%
#     
#   #create counts for number of m/f charges arrested/filed/convicted --- CHECK THIS
#   mutate(arrested_mcharge_count = length(unique(cnt_order[arrest_misd_flag == 1 & arrested_flag ==1])),
#          filed_mcharge_count = length(unique(cnt_order[court_misd_flag == 1 & filed_flag ==1])),
#          convicted_mcharge_count = length(unique(cnt_order[conviction_misd_flag == 1 & convicted_flag ==1])),
#          arrested_fcharge_count = length(unique(cnt_order[arrest_felony_flag == 1 & arrested_flag ==1])),
#          filed_fcharge_count = length(unique(cnt_order[court_felony_flag == 1 & filed_flag ==1])),
#          convicted_fcharge_count = length(unique(cnt_order[conviction_felony_flag == 1 & convicted_flag ==1]))) %>%
#   
#   #this will max the relevant flags within each cycle so that they will be kept in the collapse
#   mutate(across(matches("arrest_.*_flag"), ~if_else(sum(arrested_flag) == 0, 0, max(.x[arrested_flag == 1]))),
#          across(matches("court_.*_flag"), ~if_else(sum(filed_flag) == 0, 0, max(.x[filed_flag == 1]))),
#          across(matches("conviction_.*_flag"), ~if_else(sum(convicted_flag) == 0, 0, max(.x[convicted_flag == 1])))) %>%
#   
#   mutate(max_arrest_hier = if_else(sum(arrested_flag) == 0, 1e6, min(hierarchy[arrested_flag == 1])),
#          max_court_hier = if_else(sum(filed_flag) == 0, 1e6, min(hierarchy[filed_flag == 1])),
#          max_conv_hier = if_else(sum(convicted_flag) == 0, 1e6, min(hierarchy[convicted_flag == 1]))) %>%
#   
#   mutate(across(c(arrested_flag, filed_flag, convicted_flag, dismissed_flag, arrest_disp, court_disp), max)) %>%
#   
#   mutate(dispo_date = max(dispo_date, na.rm = T),
#          sentence_date = min(sentence_date, na.rm = T)) %>%
#   
#   #combine qualifiers and remove "NA"s
#   mutate(offense_qual_lst = gsub(",NA|NA,","", paste(offense_qual_lst, collapse = ",")),
#          offense_qual_lst = if_else(offense_qual_lst == "NA", NA_character_, offense_qual_lst)) %>%
#   
#   ungroup() %>%
#   
#   distinct(subject_id, cyc_date, .keep_all = T) 
# )
# 
# #occasionally there is more than one county listed, or some of the rows list the county as "UNKNOWN". Not very many instances, and it looks like often the first line is not the missing one, so currently not worrying about this. Looks like it is when the arrest and court actions are in different counties. In most of these (already few) cases, the court county is missing. In very few cases there is a different county listed for arrest and court counties. 
# 
# # coll_df %>%
# #   select(-c(stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, jbsis_code))
# 
# 
# # dsam %>%
# #   group_by(cyc_date, subject_id) %>%
# #   mutate(n = length(unique(stp_ori_cnty_name))) %>%
# #   mutate(counties = paste(stp_ori_cnty_name, collapse = ", ")) %>%
# #   ungroup %>%
# #   filter(n>1) %>%
# #   select(counties, stp_ori_cnty_name, stp_ori_type_descr) 
# #   distinct(cyc_date, subject_id, .keep_all = T) %>%
# #   count(counties)
# 
# # coll_df
# 
# #do i want to do more counts instead of just flags? currently just counting number of f/m for arrest/filed/convicted, does it matter for the rest of the flags how many counts there were? probably too much detail for criminal history, but would this be useful for the current cycle?
```


Collapse each cycle (second version, using dispo date, Feb 2021. Inefficient -- see more efficient version below)
```{r} 
# 
# ## 
# 
# suppressWarnings(
# coll_df <- dsam %>%
# 
#   mutate(arrested_flag = if_else(grepl("Arrest", stp_ori_type_descr), 1, 0),
#          filed_flag = if_else(grepl("Court", stp_ori_type_descr), 1, 0),
#          convicted_flag =  if_else(grepl("^CONVICTED", disp_descr), 1, 0),
#          dismissed_flag = if_else(grepl("DISCH|ACQUIT|DISMISSED|REL|REJ", disp_descr), 1, 0)) %>% 
#   
#   mutate(across(contains("flag"), ~if_else(is.na(.x), 0, .x))) %>%
#  
#   mutate(hierarchy = if_else(is.na(hierarchy) | hierarchy == "0", 1e6, as.numeric(hierarchy))) %>%
#   mutate(sentence_date = if_else(!is.na(sent_order), stp_event_date, as_date(NA_character_))) %>%
#   
#   ##adjust sentence indicators to account for suspended sentences
#   ## first deal with within each count to cancel out suspended jail/prison sentences
#   #this part still needs to use cycle date because it needs to be by count
#   group_by(subject_id, cyc_date, cnt_order) %>%
#   
#   mutate(sent_ex_suspended_flag = max(sent_ex_suspended_flag),
#          sent_imp_suspended_flag = max(sent_imp_suspended_flag),
#          sent_prison_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_prison_flag),
#          sent_jail_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_jail_flag)) %>%
#   
#   #this version will now collapse to the person-disposition rather than the person-cycle, since sometimes multiple arrests are rolled into a single disposition
#   group_by(subject_id, dispo_date) %>%
#   
#   #count the number of unique cycles that were collapsed
#   mutate(combined_cycles_count = length(unique(cyc_date))) %>%
#   
#   #how should concurrent sentences be treated? looked at instances, and appears to be used inconsistently, sometimes when there is no other sentence for it to be concurrent with. could do max instead of sum when there is a concurrent flag, but in cases with more than 2 sentences this may not be correct. probably best to leave as is. 
#   mutate(prison_length_days = sum(sent_length_days[sent_prison_flag == 1]),
#          jail_length_days = sum(sent_length_days[sent_jail_flag == 1]),
#          probation_length_days = sum(sent_length_days[sent_probation_flag == 1]),
#          #probation length will be incorrect in cases where there is a suspended sentence with no probation term specified
#          sent_probation_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag == 1, 1, max(sent_probation_flag))) %>%
#   mutate(across(matches("sent_.*_flag"), max)) %>%
#     
#   #create counts for number of m/f charges arrested/filed/convicted --- CHECK THIS
#   mutate(arrested_mcharge_count = length(unique(cnt_order[arrest_misd_flag == 1 & arrested_flag ==1])),
#          filed_mcharge_count = length(unique(cnt_order[court_misd_flag == 1 & filed_flag ==1])),
#          convicted_mcharge_count = length(unique(cnt_order[conviction_misd_flag == 1 & convicted_flag ==1])),
#          arrested_fcharge_count = length(unique(cnt_order[arrest_felony_flag == 1 & arrested_flag ==1])),
#          filed_fcharge_count = length(unique(cnt_order[court_felony_flag == 1 & filed_flag ==1])),
#          convicted_fcharge_count = length(unique(cnt_order[conviction_felony_flag == 1 & convicted_flag ==1]))) %>%
#   
#   #this will max the relevant flags within each cycle so that they will be kept in the collapse
#   mutate(across(matches("arrest_.*_flag"), ~if_else(sum(arrested_flag) == 0, 0, max(.x[arrested_flag == 1]))),
#          across(matches("court_.*_flag"), ~if_else(sum(filed_flag) == 0, 0, max(.x[filed_flag == 1]))),
#          across(matches("conviction_.*_flag"), ~if_else(sum(convicted_flag) == 0, 0, max(.x[convicted_flag == 1])))) %>%
#   
#   mutate(max_arrest_hier = if_else(sum(arrested_flag) == 0, 1e6, min(hierarchy[arrested_flag == 1])),
#          max_court_hier = if_else(sum(filed_flag) == 0, 1e6, min(hierarchy[filed_flag == 1])),
#          max_conv_hier = if_else(sum(convicted_flag) == 0, 1e6, min(hierarchy[convicted_flag == 1]))) %>%
#   
#   mutate(across(c(arrested_flag, filed_flag, convicted_flag, dismissed_flag, arrest_disp, court_disp), max)) %>%
#   
#   #keep the earliest arrest date (cycle date) associated with the disposition, and the earliest sentence date, and youngest arrest age
#   mutate(cyc_date = min(cyc_date, na.rm = T),
#          cyc_age = min(cyc_age, na.rm = T),
#          sentence_date = min(sentence_date, na.rm = T),
#          prob_end_date = if_else(sent_probation_flag == 1, sentence_date + probation_length_days, as_date("1800-01-01"))) %>%
#   
#   #combine qualifiers and remove "NA"s
#   mutate(offense_qual_lst = gsub(",NA|NA,","", paste(offense_qual_lst, collapse = ",")),
#          offense_qual_lst = if_else(offense_qual_lst == "NA", NA_character_, offense_qual_lst)) %>%
#   
#   ungroup() %>%
#   
#   distinct(subject_id, dispo_date, .keep_all = T) 
# )
# 
# #occasionally there is more than one county listed, or some of the rows list the county as "UNKNOWN". Not very many instances, and it looks like often the first line is not the missing one, so currently not worrying about this. Looks like it is when the arrest and court actions are in different counties. In most of these (already few) cases, the court county is missing. In very few cases there is a different county listed for arrest and court counties. 
# 
# # coll_df %>%
# #   select(-c(stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, jbsis_code))

```

Collapse each cycle (third version, using dispo date, Feb 2021. Made more efficient, this version run 2.16.21)
```{r}
# 
# ## 
# suppressWarnings(
# coll_df <- dsam %>%
# 
#   mutate(arrested_flag = if_else(grepl("Arrest", stp_ori_type_descr), 1, 0),
#          filed_flag = if_else(grepl("Court", stp_ori_type_descr), 1, 0),
#          convicted_flag =  if_else(grepl("^CONVICTED", disp_descr), 1, 0),
#          dismissed_flag = if_else(grepl("DISCH|ACQUIT|DISMISSED|REL|REJ", disp_descr), 1, 0)) %>% 
#   
#   mutate(across(contains("flag"), ~if_else(is.na(.x), 0, .x))) %>%
# 
#   mutate(hierarchy = if_else(is.na(hierarchy) | hierarchy == "0", 1e6, as.numeric(hierarchy))) %>%
#   mutate(sentence_date = if_else(!is.na(sent_order), stp_event_date, as_date(NA_character_))) %>%
#   
#   ##adjust sentence indicators to account for suspended sentences
#   ## first deal with within each count to cancel out suspended jail/prison sentences
#   #this part still needs to use cycle date because it needs to be by count
#   group_by(subject_id, cyc_date, cnt_order) %>%
#   
#   mutate(sent_ex_suspended_flag = max(sent_ex_suspended_flag),
#          sent_imp_suspended_flag = max(sent_imp_suspended_flag),
#          sent_prison_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_prison_flag),
#          sent_jail_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_jail_flag)) %>%
#   ungroup() %>%
#   
#   mutate(prison_length_days = if_else(sent_prison_flag == 1, sent_length_days, 0),
#          jail_length_days = if_else(sent_jail_flag == 1, sent_length_days, 0),
#          probation_length_days = if_else(sent_probation_flag == 1, sent_length_days, 0)) %>%
#   
#   mutate(max_arrest_hier = if_else(arrested_flag == 1, hierarchy, 1e6),
#          max_court_hier = if_else(filed_flag == 1, hierarchy, 1e6),
#          max_conv_hier = if_else(convicted_flag == 1, hierarchy, 1e6)) %>%
#   
#   #this version will now collapse to the person-disposition rather than the person-cycle, since sometimes multiple arrests are rolled into a single disposition
#   group_by(subject_id, dispo_date) %>%
#   
#   #count the number of unique cycles that were collapsed
#   mutate(combined_cycles_count = length(unique(cyc_date))) %>%
#   
#   #how should concurrent sentences be treated? looked at instances, and appears to be used inconsistently, sometimes when there is no other sentence for it to be concurrent with. could do max instead of sum when there is a concurrent flag, but in cases with more than 2 sentences this may not be correct. probably best to leave as is. 
#   mutate(prison_length_days = sum(prison_length_days),
#          jail_length_days = sum(jail_length_days),
#          probation_length_days = sum(probation_length_days),
#          #probation length will be incorrect in cases where there is a suspended sentence with no probation term specified
#          sent_probation_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag == 1, 1, max(sent_probation_flag))) %>%
#   mutate(across(matches("sent_.*_flag"), max)) %>%
#     
#   #create counts for number of m/f charges arrested/filed/convicted --- CHECK THIS
#   mutate(arrested_mcharge_count = n_distinct(cnt_order[arrest_misd_flag == 1]),
#          filed_mcharge_count = n_distinct(cnt_order[court_misd_flag == 1]),
#          convicted_mcharge_count = n_distinct(cnt_order[conviction_misd_flag == 1]),
#          arrested_fcharge_count = n_distinct(cnt_order[arrest_felony_flag == 1]),
#          filed_fcharge_count = n_distinct(cnt_order[court_felony_flag == 1]),
#          convicted_fcharge_count = n_distinct(cnt_order[conviction_felony_flag == 1])) %>%
#   
#   #this will max the relevant flags within each cycle so that they will be kept in the collapse
#   mutate(across(matches("flag"), max)) %>%
#   
#   mutate(max_arrest_hier = max(max_arrest_hier),
#          max_court_hier = max(max_court_hier),
#          max_conv_hier = max(max_conv_hier)) %>%
#   
#   mutate(across(c(arrest_disp, court_disp), max)) %>%
#   
#   #keep the earliest arrest date (cycle date) associated with the disposition, and the earliest sentence date, and youngest arrest age
#   mutate(cyc_date = min(cyc_date, na.rm = T),
#          cyc_age = min(cyc_age, na.rm = T),
#          sentence_date = min(sentence_date, na.rm = T),
#          prob_end_date = if_else(sent_probation_flag == 1, sentence_date + probation_length_days, as_date("1800-01-01"))) %>%
#   
#   #combine qualifiers and remove "NA"s
#   mutate(offense_qual_lst = gsub(",NA|NA,","", paste(offense_qual_lst, collapse = ",")),
#          offense_qual_lst = if_else(offense_qual_lst == "NA", NA_character_, offense_qual_lst)) %>%
#   
#   ungroup() %>%
#   
#   distinct(subject_id, dispo_date, .keep_all = T) 
# )
# 
# rm(dsam)
# 
# #occasionally there is more than one county listed, or some of the rows list the county as "UNKNOWN". Not very many instances, and it looks like often the first line is not the missing one, so currently not worrying about this. Looks like it is when the arrest and court actions are in different counties. In most of these (already few) cases, the court county is missing. In very few cases there is a different county listed for arrest and court counties. 
# 
# # coll_df %>%
# #   select(-c(stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, jbsis_code))

```

Collapse each cycle (fourth version, using dispo date, Feb 2021. Made more efficient. and fixed errors from 2.16.21 version which left out a lot of things because they lacked disposition dates)
```{r}

## 
suppressWarnings(
coll_df <- dsam %>%

  mutate(arrested_flag = if_else(grepl("Arrest", stp_ori_type_descr), 1, 0),
         filed_flag = if_else(grepl("Court", stp_ori_type_descr), 1, 0),
         convicted_flag =  if_else(grepl("^CONVICTED", disp_descr), 1, 0),
         dismissed_flag = if_else(grepl("DISCH|ACQUIT|DISMISSED|REL|REJ", disp_descr), 1, 0)) %>% 
  
  mutate(across(contains("flag"), ~if_else(is.na(.x), 0, .x))) %>%

  mutate(hierarchy = if_else(is.na(hierarchy) | hierarchy == "0", 1e6, as.numeric(hierarchy))) %>%
  mutate(sentence_date = if_else(!is.na(sent_order), stp_event_date, as_date(NA_character_))) %>%
  
  #create a disposition date to attach to all steps in a cycle
  group_by(subject_id, cyc_date) %>%
  mutate(cycle_dispo_date = max(dispo_date, na.rm = T)) %>%
  
  ##adjust sentence indicators to account for suspended sentences
  ## first deal with within each count to cancel out suspended jail/prison sentences
  #this part still needs to use cycle date because it needs to be by count
  group_by(subject_id, cyc_date, cnt_order) %>%
  
  mutate(sent_ex_suspended_flag = max(sent_ex_suspended_flag),
         sent_imp_suspended_flag = max(sent_imp_suspended_flag),
         sent_prison_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_prison_flag),
         sent_jail_flag = if_else(sent_imp_suspended_flag == 1, 0, sent_jail_flag)) %>%
  
  ungroup() %>%
  
  mutate(prison_length_days = if_else(sent_prison_flag == 1, sent_length_days, 0),
         jail_length_days = if_else(sent_jail_flag == 1, sent_length_days, 0),
         probation_length_days = if_else(sent_probation_flag == 1, sent_length_days, 0)) %>%
  
  mutate(max_arrest_hier = if_else(arrested_flag == 1, hierarchy, 1e6),
         max_court_hier = if_else(filed_flag == 1, hierarchy, 1e6),
         max_conv_hier = if_else(convicted_flag == 1, hierarchy, 1e6)) %>%
  
  #this version will now collapse to the person-disposition rather than the person-cycle, since sometimes multiple arrests are rolled into a single disposition
  group_by(subject_id, cycle_dispo_date) %>%
  
  #count the number of unique cycles that were collapsed
  mutate(combined_cycles_count = length(unique(cyc_date))) %>%
  
  #how should concurrent sentences be treated? looked at instances, and appears to be used inconsistently, sometimes when there is no other sentence for it to be concurrent with. could do max instead of sum when there is a concurrent flag, but in cases with more than 2 sentences this may not be correct. probably best to leave as is. 
  mutate(prison_length_days = sum(prison_length_days),
         jail_length_days = sum(jail_length_days),
         probation_length_days = sum(probation_length_days),
         #probation length will be incorrect in cases where there is a suspended sentence with no probation term specified
         sent_probation_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag == 1, 1, max(sent_probation_flag))) %>%
    
  #create counts for number of m/f charges arrested/filed/convicted --- CHECK THIS
  mutate(arrested_mcharge_count = n_distinct(cnt_order[arrest_misd_flag == 1]),
         filed_mcharge_count = n_distinct(cnt_order[court_misd_flag == 1]),
         convicted_mcharge_count = n_distinct(cnt_order[conviction_misd_flag == 1]),
         arrested_fcharge_count = n_distinct(cnt_order[arrest_felony_flag == 1]),
         filed_fcharge_count = n_distinct(cnt_order[court_felony_flag == 1]),
         convicted_fcharge_count = n_distinct(cnt_order[conviction_felony_flag == 1])) %>%
  
  #this will max the relevant flags within each disposition so that they will be kept in the collapse
  mutate(across(contains("flag"), max)) %>%
  
  mutate(max_arrest_hier = max(max_arrest_hier),
         max_court_hier = max(max_court_hier),
         max_conv_hier = max(max_conv_hier)) %>%
  
  mutate(across(c(arrest_disp, court_disp), max)) %>%
  
  #keep the earliest arrest date (cycle date) associated with the disposition, and the earliest sentence date, and youngest arrest age
  mutate(cyc_date = min(cyc_date, na.rm = T),
         cyc_age = min(cyc_age, na.rm = T),
         sentence_date = min(sentence_date, na.rm = T),
         prob_end_date = if_else(sent_probation_flag == 1, sentence_date + probation_length_days, as_date("1800-01-01"))) %>%
  
  #combine qualifiers and remove "NA"s
  mutate(offense_qual_lst = gsub(",NA|NA,","", paste(offense_qual_lst, collapse = ",")),
         offense_qual_lst = if_else(offense_qual_lst == "NA", NA_character_, offense_qual_lst)) %>%
  
  ungroup() %>%
  
  distinct(subject_id, cycle_dispo_date, .keep_all = T) 
)

rm(dsam)

#occasionally there is more than one county listed, or some of the rows list the county as "UNKNOWN". Not very many instances, and it looks like often the first line is not the missing one, so currently not worrying about this. Looks like it is when the arrest and court actions are in different counties. In most of these (already few) cases, the court county is missing. In very few cases there is a different county listed for arrest and court counties. 

# coll_df %>%
#   select(-c(stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, jbsis_code))

```

Old code and diagnostics
```{r}
# dsam %>%
#   #this piece is modified from Noah's code, check if needed
#   mutate(arrested_flag = if_else(grepl("Arrest", stp_ori_type_descr), 1, 0),
#          filed_flag = if_else(grepl("Court", stp_ori_type_descr), 1, 0),
#          convicted_flag =  if_else(grepl("^CONVICTED", disp_descr), 1, 0),
#          dismissed_flag = if_else(grepl("DISCH|ACQUIT|DISMISSED|REL|REJ", disp_descr), 1, 0)) %>%
#   filter(subject_id == "35878334") %>%
#   mutate(across(matches("arrest_.*_flag"), ~if_else(sum(arrested_flag) == 0, 0, max(.x[arrested_flag == 1]))),
#          across(matches("court_.*_flag"), ~if_else(sum(filed_flag) == 0, 0, max(.x[filed_flag == 1]))),
#          across(matches("conviction_.*_flag"), ~~if_else(sum(convicted_flag) == 0, 0, max(.x[convicted_flag == 1]))))
# 
# 
# dsam %>%
#   count(across(matches("arrest_.*_flag")))
# 
# dsam %>%
#   group_by(subject_id, cyc_date) %>%
#   mutate(sent_concurrent_flag = max(sent_concurrent_flag)) %>%
#   ungroup() %>%
#   filter(sent_concurrent_flag == 1) %>%
#   arrange(subject_id, cyc_date)
# 
# dsam %>%
#   count(across(matches("sent_.*_flag")), sort = TRUE)
# 
# 
# #collapse code from pilot
# court_dispo <- court_charge %>%
#   mutate(disposition_type = ordered(disposition_type, levels = c("Other", "Dismissed", "Not_Guilty", "Nolo_Contendere", "Guilty"))) %>%
#   mutate(sentence_type = ordered(sentence_type, levels = c("Other", "Probation", "Jail", "Prison"))) %>%
#   group_by(court_case_id) %>%
#   mutate(hierarchy = if_else(is.na(hierarchy), 1e6, as.numeric(hierarchy))) %>%
#   group_by(court_case_id) %>%
#   mutate(disposition_date = max(disposition_date, na.rm = T),
#          disposition_type = max(disposition_type),
#          conviction_flag = if_else(disposition_type %in% c("Guilty","Nolo_Contendere"), 1, 0),
#          sentence_date = if_else(conviction_flag == 1, min(sentence_date, na.rm = T), as_date(NA)),
#          sentence_type = max(sentence_type)) %>%
#   # mutate(max_court_charge_level = court_charge_level[hierarchy == min(hierarchy)][1],
#   #        max_court_charge_code = court_charge_code[hierarchy == min(hierarchy)][1],
#   #        max_court_charge = court_charge[hierarchy == min(hierarchy)][1],
#   #        max_charge_description = master_charge_description[hierarchy == min(hierarchy)][1],
#   #        max_hier = min(hierarchy)) %>%
#   mutate_at(vars(contains("flag")), funs(if_else(is.na(.), 0, as.numeric(.)))) %>%
#   mutate_at(vars(contains("flag")), funs("count" = sum(.))) %>%
#   mutate_at(vars(contains("flag")), max) %>%
#   filter(hierarchy == min(hierarchy)) %>%
#   ungroup() %>%
#   distinct(court_case_id, .keep_all = T)
# 
# 
#     # sent_prison_count = case_when(sent_imp_suspended_flag == 0 ~ sum(sent_prison_flag),
#     #                                    sent_imp_suspended_flag ==1 & sum(sent_prison_flag) > 0 ~ sum(sent_prison_flag) - 1,
#     #                                    sum(sent_prison_flag) == 0 ~ 0),
#     #      sent_jail_count = case_when(sent_imp_suspended_flag == 0 | sent_prison_count < sum(sent_prison_flag) ~ sum(sent_jail_flag),
#     #                                  sent_imp_suspended_flag == 1 & sum(sent_jail_flag) > 0 ~ sum(sent_jail_flag) - 1,
#     #                                  sum(sent_jail_flag) == 0 ~ 0)
# 
# coll_df %>%
#   count(sent_prison_flag, sent_jail_flag, sent_probation_flag, sent_imp_suspended_flag, sent_ex_suspended_flag) %>%
#   arrange(sent_prison_flag, sent_jail_flag, sent_probation_flag, sent_imp_suspended_flag, sent_ex_suspended_flag)
# 
# doj_df %>%
#   count(sent_prison_flag, sent_jail_flag,  sent_probation_flag, sent_imp_suspended_flag, sent_ex_suspended_flag)%>%
#   arrange(sent_prison_flag, sent_jail_flag, sent_probation_flag, sent_imp_suspended_flag, sent_ex_suspended_flag)
# 
# coll_df %>%
#   group_by(subject_id, cyc_date) %>%
#   filter(sum(sent_imp_suspended_flag) >0) %>%
#   ungroup()%>%
#   count(sent_prison_count, sent_jail_count, sent_prison_flag, sent_jail_flag)
# 
# coll_df %>%
#   filter(sent_imp_suspended_flag == 1)


# df <- tibble(offense_flag = 1:3, xyz = 1:3, test_flag = 11:13, new_flag = 21:23)
# 
# 
# df %>%
#   mutate(across(matches("flag"), max))
# 



```

Sample code from noah for lag
```{r}
# df <- tibble(x = c(1:3, NA_integer_, 5))
# df <- tibble(x = c("a", "b", "c"))
# 
# df %>%
# mutate(y = cumsum(lag(x, default = 0)))
# 
# df %>%
# mutate(prior_property_flag = cummax(lag(property_flag, default = 0)),
# prior_hierarchy = cummin(lag(hierarchy, default = 1e6)))
# 
# lag(df$x, default = "")
# 
# cummax(na.exclude(lag(df$x, default = 0)))
# 
# df <- tibble(x = c(as_date("2019-01-01"), as_date("2019-02-02"), NA, as_date("2019-03-03")))
# 
# as_date(cummax(nafill(lag(as.integer(df$x), default = -62091), type = "const", fill = -62091)))
# 
# ?nafill
# as.integer(as_date("1800-01-01"))
# 
# test = tibble(dispo_date = doj_df$dispo_date)
# 
# test %>%
#   mutate(nac = as.integer(dispo_date),
#          naaaaa = is.na(nac))
#   mutate(dispo_date = if_else(is.na(dispo_date), as.integer(as_date("1800-01-01")), as.integer(dispo_date)))
```

Collapse historical cycles by person (version used for January 2021 collapse, arranged by cycle date)
```{r}
# #remove useless fields
# doj_df <- coll_df %>%
#   select(-c(stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, summary_code, special_flag))
# #now removing the rest of these before the cycle collapse
# #serious_felony_flag, violent_felony_flag, violent_psa_flag, capital_flag, dv_flag, marijuana_flag, sup_vio_flag, fta_flag, sex_flag, dui_flag,  restrain_flag, jbsis_m_property_flag, jbsis_m_drug_flag, jbsis_f_property_flag, jbsis_f_drug_flag, dv_possible_flag, felony_flag, misd_flag, inf_flag))
# 
# 
# hist_collapse <- doj_df %>%
#   arrange(cyc_date) %>%
#   group_by(subject_id) %>%
#   mutate(days_prior_prison = cumsum(lag(prison_length_days, default = 0)),
#          days_prior_jail = cumsum(lag(jail_length_days, default = 0)),
#          days_prior_probation = cumsum(lag(probation_length_days, default = 0))) %>%
#     
#   #combine qualifiers and remove "NA"s
#   mutate(prior_quals = gsub(",NA|NA,","", paste(lag(offense_qual_lst, default = "NA"), collapse = ",")),
#          prior_quals = if_else(prior_quals == "NA", NA_character_, prior_quals)) %>%
#   
#   mutate(prior_dispo_date = if_else(is.na(as.numeric(dispo_date)), as.numeric(as_date("1800-01-01")), as.numeric(dispo_date)),
#          prior_dispo_date = as_date(cummax(lag(prior_dispo_date, default = -62091))), #keep the most recent prior disposition date, if no priors will default to date of "1800-01-01"
#          citizen = if_else(is.na(citizen), 0, citizen),
#          prior_citizen = cummax(lag(citizen)),
#          age_first_dispo = min(cyc_age, na.rm = T)) %>%
# 
#   #create counts for each flag
#   mutate(across(contains("flag"), ~cumsum(lag(.x, default = 0)), .names = "prior_{.col}_count")) %>%
#   mutate(across(contains("hier"), ~cummin(lag(.x, default = 1e6)), .names = "prior_{.col}")) %>%
#   
#   ungroup() 
# 
# #filter out the dispositions in 2019
# 
# dispos <- hist_collapse %>%
#   filter(year(dispo_date) == 2019)
# 
# 
# # dispos %>%
# #   select(subject_id, cyc_date, dispo_date, court_disp, prior_dispo_date)
# 
# #there are some weird cases hanging around that have very old cycle dates but dispo dates in 2019 -- look into what the deal is with these
# 
# # dsam %>%
# #   filter(summary_code == 1000) %>%
# #   count(join_var) %>%
# #   arrange(desc(n))
# 
# # dispos %>%
# #   mutate(totm = arrest_summ_m_violent_flag+ arrest_summ_m_property_flag + arrest_summ_m_drug_flag + arrest_summ_m_other_sex_flag + arrest_summ_m_other_flag) %>%
# #   mutate(totf = arrest_summ_f_violent_flag+ arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_summ_f_other_sex_flag + arrest_summ_f_other_flag) %>%
# #   filter(totf<1)
# # 
# # dispos %>%
# #   mutate(tot = arrest_summ_f_violent_flag+ arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_summ_f_other_sex_flag + arrest_summ_f_other_flag) %>%
# #   count(tot)
# # 
# # charge_hier %>%
# #   mutate(totm = summ_m_violent_flag+ summ_m_property_flag + summ_m_drug_flag + summ_m_other_sex_flag + summ_m_other_flag) %>%
# #   mutate(totf = summ_f_violent_flag+ summ_f_property_flag + summ_f_drug_flag + summ_f_other_sex_flag + summ_f_other_flag) %>%
# #   filter(totf >1)


```

Collapse historical cycles by person (version used for February 2021 collapse, arranged by dispo date)
```{r}
#remove useless fields
doj_df <- coll_df %>%
  select(-c(cyc_order, stp_order, stp_event_date, stp_type_code, stp_type_descr, stp_ori_type_descr, cnt_order, disp_date, offense_code, offense_descr, join_var, offense_toc, disp_order, disp_code, conv_stat_code, conv_stat_descr, sent_order, sent_loc_descr, sent_length, sent_time_descr, offense_orig, offense_stat, offense, charge_level, charge_code, charge, master_charge_description, hierarchy, summary_code, special_flag))
#now removing the rest of these before the cycle collapse
#serious_felony_flag, violent_felony_flag, violent_psa_flag, capital_flag, dv_flag, marijuana_flag, sup_vio_flag, fta_flag, sex_flag, dui_flag,  restrain_flag, jbsis_m_property_flag, jbsis_m_drug_flag, jbsis_f_property_flag, jbsis_f_drug_flag, dv_possible_flag, felony_flag, misd_flag, inf_flag))


hist_collapse <- doj_df %>%
  arrange(cycle_dispo_date) %>%
  group_by(subject_id) %>%
  mutate(days_prior_prison = cumsum(lag(prison_length_days, default = 0)),
         days_prior_jail = cumsum(lag(jail_length_days, default = 0)),
         days_prior_probation = cumsum(lag(probation_length_days, default = 0))) %>%
    
  #combine qualifiers and remove "NA"s
  mutate(prior_quals = gsub(",NA|NA,","", paste(lag(offense_qual_lst, default = "NA"), collapse = ",")),
         prior_quals = if_else(prior_quals == "NA", NA_character_, prior_quals)) %>%
  
  mutate(prior_conv_date = if_else(is.na(as.numeric(dispo_date))| convicted_flag == 0, as.numeric(as_date("1800-01-01")), as.numeric(dispo_date)),
         prior_conv_date = as_date(cummax(lag(prior_conv_date, default = -62091))), #keep the most recent prior conviction date, if no prior convictions will default to date of "1800-01-01"
         prior_prob_end_date = if_else(is.na(as.numeric(prob_end_date)), as.numeric(as_date("1800-01-01")), as.numeric(prob_end_date)),
         prior_prob_end_date = as_date(cummax(lag(prior_prob_end_date, default = -62091))), #keep the most recent prior probation end date, if no prior probation will default to date of "1800-01-01"
         prior_cycles_count = cumsum(lag(combined_cycles_count, default = 0)),
         citizen = if_else(is.na(citizen), 0, citizen),
         prior_citizen = cummax(lag(citizen)),
         age_first_dispo = min(cyc_age, na.rm = T)) %>%

  #create counts for each flag
  mutate(across(contains("flag"), ~cumsum(lag(.x, default = 0)), .names = "prior_{.col}_count")) %>%
  mutate(across(contains("hier"), ~cummin(lag(.x, default = 1e6)), .names = "prior_{.col}")) %>%
  
  ungroup() 

#filter out the dispositions in 2019

dispos <- hist_collapse %>%
  filter(year(cycle_dispo_date) == 2019) %>%
  mutate(on_prob = if_else(prior_conv_date < cyc_date & prior_prob_end_date > cyc_date, 1, 0))


# save(dispos, file = "Dispos Feb 2021.RData")
# save(hist_collapse, file = "History collapse Feb 2021.RData")

```

Diagnostics
```{r}
# dispos %>%
#   select(subject_id, cyc_date, dispo_date, court_disp, prior_dispo_date)

#there are some weird cases hanging around that have very old cycle dates but dispo dates in 2019 -- look into what the deal is with these

# dsam %>%
#   filter(summary_code == 1000) %>%
#   count(join_var) %>%
#   arrange(desc(n))

# dispos %>%
#   mutate(totm = arrest_summ_m_violent_flag+ arrest_summ_m_property_flag + arrest_summ_m_drug_flag + arrest_summ_m_other_sex_flag + arrest_summ_m_other_flag) %>%
#   mutate(totf = arrest_summ_f_violent_flag+ arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_summ_f_other_sex_flag + arrest_summ_f_other_flag) %>%
#   filter(totf<1)
# 
# dispos %>%
#   mutate(tot = arrest_summ_f_violent_flag+ arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_summ_f_other_sex_flag + arrest_summ_f_other_flag) %>%
#   count(tot)
# 
# charge_hier %>%
#   mutate(totm = summ_m_violent_flag+ summ_m_property_flag + summ_m_drug_flag + summ_m_other_sex_flag + summ_m_other_flag) %>%
#   mutate(totf = summ_f_violent_flag+ summ_f_property_flag + summ_f_drug_flag + summ_f_other_sex_flag + summ_f_other_flag) %>%
#   filter(totf >1)

```

OLD collapse of historical cycles
```{r}
# #most individuals have 1 2019 disposition. A couple have none, and some have more than 1. Unit of analysis should be the disposition. Separate out the non-current dispositions and collapse them down to the person, and then attach the collapsed criminal histories by person to each current disposition. 
# 
# dispos_2019 <- doj_df %>%
#   filter(year(dispo_date) == 2019)
# 
# histories <- doj_df %>%
#   filter(year(dispo_date) != 2019) #what about rows with no dispo date? do these all not have a disposition? why are they in this dataset? should I include these for arrests?
#   
# hist_collapse <- histories %>%
#   group_by(subject_id) %>%
#   mutate(days_prior_prison = sum(prison_length_days),
#          days_prior_jail = sum(jail_length_days),
#          days_prior_probation = sum(probation_length_days)) %>%
#     
#   #combine qualifiers and remove "NA"s
#   mutate(prior_quals = gsub(",NA|NA,","", paste(offense_qual_lst, collapse = ",")),
#          prior_quals = if_else(prior_quals == "NA", NA_character_, prior_quals)) %>%
#   
#   mutate(prior_dispo_date = max(dispo_date, na.rm = T), #keep the most recent prior disposition date
#          citizen = if_else(is.na(citizen), 0, citizen),
#          prior_citizen = max(citizen, na.rm = T),
#          age_first_dispo = min(cyc_age, na.rm = T)) %>%
# 
#   #create counts for each flag
#   mutate(across(contains("flag"), sum, .names = "prior_{.col}_count")) %>%
#   mutate(across(contains("hier"), min, .names = "prior_{.col}")) %>%
#   
#   ungroup() %>%
#   distinct(subject_id, .keep_all = T) %>%
# 
#   select(subject_id, contains("prior"), age_first_dispo)
#   
#   
# #join histories to 2019 dispositions
# doj_df <- dispos_2019 %>%
#   left_join(hist_collapse)
# 
# #fwrite(doj_df, "G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Cleaned DOJ data small sample 1.4.2021.csv")
# 
# #should add some kind of indicator for concurrent cases, or additional 2019 cases. Or should add earlier 2019 cases to criminal history for later cases in 2019? yeesh.
```

Diagnostics
```{r}


# doj_df %>%
#   mutate(dispo_2019 = if_else(year(dispo_date) == 2019, 1, 0)) %>%
#   count(dispo_2019)
#   group_by(subject_id) %>%
#   mutate(current_count = sum(dispo_2019, na.rm = T)) %>%
#   ungroup() %>%
#   distinct(subject_id, .keep_all = T) %>%
#   count(current_count)
#   
#   
# doj_df %>%
#   count(yr = year(dispo_date)) %>%
#   arrange(desc(n)) %>%
#   mutate(yrtf = if_else(yr == 2019, T, F))
# 
# doj_df %>%
#   distinct(subject_id)
# 
# str_replace_na(c(1, 2, 3, NA_character_), replacement = 0)
# 
# histories %>%
#   select(contains("flag"))
#   select(contains("hier"))
# dsam %>%
#   select(contains("date"))
# 
# dsam %>%
#   filter(stp_ori_type_descr == "Court")
# 
# dsam %>%
#   count(subject_id, cyc_order)
# 
# summary(dsam$stp_event_date)
# 
# dsam %>%
#   filter(subject_id == "1000093" & cyc_order == "102000000000")
# 
# dsam %>%
#   filter(!is.na(stp_event_date) & !is.na(disp_date)) %>%
#   select(stp_event_date, disp_date)
# 
# dsam %>%
#   filter(disp_code == "1008")
# 
# 
# dsam %>%
#   filter(disp_date > as_date("2019-01-01")) %>%
#   arrange(stp_event_date) %>%
#   distinct(subject_id, cyc_order, .keep_all = T)
# 
# dsam %>%
#   filter(offense_code == "00001")
# 
# dsam %>%
#   filter(!is.na(disp_descr) & is.na(disp_date)) %>%
#   count(stp_ori_type_descr)
# 
# dsam %>%
#   filter(stp_event_date == disp_date)
# 
# dsam %>%
#   filter(!is.na(disp_date)) %>%
#   count(stp_type_descr) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   filter(stp_ori_type_descr == "Court" & !is.na(disp_descr)) %>%
#   count(stp_type_descr, disp_descr) %>%
#   arrange(desc(n))
# 
# #court dispositions do not use disp_date! use stp_event_date instead.
# #not all disp_descr look like they are final dispositions, need to sort out which ones are (e.g. bail forfeited, bench warrant)
# 
# dsam %>%
#   count(stp_type_descr) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   filter(grepl("PROS", disp_descr)) %>%
#   filter(is.na(disp_date)) %>%
#   count(stp_ori_type_descr, stp_type_descr, disp_descr)
# 


# dsam %>%
#   count(stp_type_descr, disp_descr) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   count(stp_ori_type_descr, stp_type_descr) %>%
#   arrange(desc(n))
# 
# dsam %>%
#   filter(stp_type_descr == "CDC CUSTODY")
# 
# dsam %>%
#   filter(stp_type_descr %in% c("ARREST/DETAINED/CITED", "COURT ACTION")) %>%
#   count(disp_descr) %>%
#   arrange(desc(n))

dispos %>%
  count(arrest_felony_flag, court_felony_flag, conviction_felony_flag)

dispos %>%
  count(arrested_fcharge_count)

dispos %>%
  count(combined_cycles_count)

dsam %>%
  filter(!is.na(dispo_date)) %>%
  group_by(subject_id, cyc_date) %>%
  mutate(n = length(unique(dispo_date))) %>%
  ungroup() %>%
  filter(n>1) %>%
  select(subject_id, cyc_date, dispo_date, stp_ori_type_descr, offense_toc)

dsam %>%
  filter(arrest_felony_flag == 1) %>%
  distinct(subject_id, dispo_date)

dsam %>%
  filter(is.na(dispo_date)) %>%
  select(dispo_date, disp_date, stp_event_date, cyc_date, stp_ori_type_descr)

dispos %>%
  count(arrest_felony_flag)
```






# Load and tidy CA population data from DOF
tidy ca_age data
```{r}
ca_age <- read_xlsx("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/DOF demographic data 2019/P1B_State_Age.xlsx", sheet = 3, skip = 2, col_names =T) 


# ca_age_full <- ca_age %>%
#   # extract columns
#    select(`Population`, `2019`) %>%
#   
#   # rename column names
#   rename(Age = Population) %>%
#   
#   # remove rows that are not ages
#   slice(-c(1, 103)) %>%
# 
#   # recode variable
#   mutate(`2019` = as.integer(`2019`),
#           Age = as.integer(if_else(Age == "100+", "100", Age)),
#          
#          # add age category column
#          `Age Category` = as.factor(case_when(
#            Age <= 14 ~ "0-14 yrs",
#            Age > 14 & Age <= 19 ~ "15-19 yrs",
#            Age > 19 & Age <= 29 ~ "20-29 yrs",
#            Age > 29 & Age <= 39 ~ "30-39 yrs",
#            Age > 39 & Age <= 49 ~ "40-49 yrs",
#            Age > 49 & Age <= 59 ~ "50-59 yrs",
#            TRUE ~ "60+ yrs"
#          ))) 

ca_age18 <- ca_age %>%
 # extract columns
   select(`Population`, `2019`) %>%
  
  # rename column names
  rename(Age = Population) %>%
  
  # remove rows that are not ages
  slice(-c(1, 103)) %>%

  # recode variable
  mutate(`2019` = as.integer(`2019`),
          Age = as.integer(if_else(Age == "100+", "100", Age)),
         
         # add age category column
         `Age Category` = as.factor(case_when(
           Age <= 17 ~ "0-17 yrs",
           Age > 17 & Age <= 19 ~ "18-19 yrs",
           Age > 19 & Age <= 29 ~ "20-29 yrs",
           Age > 29 & Age <= 39 ~ "30-39 yrs",
           Age > 39 & Age <= 49 ~ "40-49 yrs",
           Age > 49 & Age <= 59 ~ "50-59 yrs",
           TRUE ~ "60+ yrs"
         ))) %>%
  
  # add frequency column
  group_by(`Age Category`) %>%
  summarise(Frequency = sum(`2019`)) %>%
  
  # add percentage column
  mutate(Percentage = Frequency / sum(Frequency) * 100)

# ca_age <- ca_age %>%
#   # extract columns
#    select(`Population`, `2019`) %>%
#   
#   # rename column names
#   rename(Age = Population) %>%
#   
#   # remove rows that are not ages
#   slice(-c(1, 103)) %>%
# 
#   # recode variable
#   mutate(`2019` = as.integer(`2019`),
#           Age = as.integer(if_else(Age == "100+", "100", Age)),
#          
#          # add age category column
#          `Age Category` = as.factor(case_when(
#            Age <= 14 ~ "0-14 yrs",
#            Age > 14 & Age <= 19 ~ "15-19 yrs",
#            Age > 19 & Age <= 29 ~ "20-29 yrs",
#            Age > 29 & Age <= 39 ~ "30-39 yrs",
#            Age > 39 & Age <= 49 ~ "40-49 yrs",
#            Age > 49 & Age <= 59 ~ "50-59 yrs",
#            TRUE ~ "60+ yrs"
#          ))) %>%
#   
#   # add frequency column
#   group_by(`Age Category`) %>%
#   summarise(Frequency = sum(`2019`)) %>%
#   
#   # add percentage column
#   mutate(Percentage = Frequency / sum(Frequency) * 100)
```

tidy ca_eth data
```{r}
ca_eth <- read_xlsx("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/DOF demographic data 2019/P1D_State_Race_Ethnicity.xlsx", sheet = 2, skip = 2, col_names =T) 

ca_eth <- ca_eth %>%
  # extract columns
   select(`Race/Ethnicity`, `2019`) %>%
  
  # remove last two rows which are total and a note
  slice(-c(8,9)) %>%

  # recode variable
  mutate(`2019` = as.integer(`2019`)) %>%
  # add percentage column
  mutate(Percentage = `2019` / sum(`2019`) * 100)
  
```

tidy ca_sex data
```{r}
ca_sex <- read_xlsx("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/DOF demographic data 2019/P1C_State_Age-Group_Sex.xlsx", sheet = 2, skip = 2, col_names =T) 

ca_sex <- ca_sex %>%
  # extract columns
   select(`Women, by age group:`, `2019`) %>%
  
   # rename column names
  rename(Sex = `Women, by age group:`) %>%
  
  # select rows that are total women and total men
  slice(23,48) %>%
  

  # recode variables
  mutate(`2019` = as.integer(`2019`),
         Sex = if_else(Sex == "Total women", "Women", "Men")) %>%
  
  # add percentage column
  mutate(Percentage = `2019` / sum(`2019`) * 100)
  
```



# Load and analyze collapsed dataset

Load collapsed dataset
```{r}
load("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Dispos.RData")
load("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/Dispos Feb 2021.RData")


df <- dispos %>%
  filter(arrest_felony_flag == 1) %>% #filter to only dispositions with a felony arrest, since there are also misdemeanor-only arrests for people who have other 2019 felony arrest dispositions
  #select(-cyc_order) %>%  #remove useless field
  rename(county = stp_ori_cnty_name,
         age = cyc_age)



rm(dispos)

dispos %>%
  count(sent_prison_flag)
  count(arrest_summ_f_drug_flag, arrest_summ_f_violent_flag, arrest_summ_f_other_flag, arrest_summ_f_other_sex_flag, arrest_summ_f_property_flag, arrest_felony_flag)
  
  df %>%
    count(sent_prison_flag)
```

Diagnostic code
```{r}
#did i order the lag collapse by cycle date or dispo date?? should be dispo date. it was by cycle date. do they often dispose of cases out of order? looks like at least some of the time. there are a lot of overlapping cycles. should re-run the collapse, ordered by dispo date
#sometimes more than one cycle has the same dispo date, i suppose the cases were rolled together, how should i deal with this? could collapse these instances before the historical collapse and treat cycles with the same dispo date as one
#new code will collapse by dispo date and keep a count of number of cycles that were collapsed

df %>%
  add_count(subject_id) %>%
  filter(n>1) %>%
  select(subject_id, cyc_date, dispo_date) %>%
  arrange(subject_id, cyc_date)

df %>%
  count(arrest_sup_vio_flag, court_sup_vio_flag, conviction_sup_vio_flag) #supervision violations accounted for at arrest are rarely filed or convicted. uncommon at arrest too, this can't be capturing everyone who is on supervision. 
# can i somehow account for whether someone is on probation in the collapse? maybe create a probation end date for each probation sentence, and then for each cycle calculate the latest prior probation end date and check whether the current cycle is before that. some probation lengths are missing

df %>%
  filter(sent_probation_flag == 1) %>% #>61k probation sentences
  count(probation_length_days, sent_imp_suspended_flag, sent_ex_suspended_flag) #536 NA lengths, 6k length 0 days (about 1/3 of them are sentence imposition suspended, and the other 2/3 are sentence execution suspended (only 1 is neither))

d2 <- df %>%
  add_count(subject_id) %>%
  filter(n>1) %>%
  select(subject_id, cyc_date, dispo_date)

d2 %>%
  group_by(subject_id) %>%
  arrange(cyc_date) %>%
  mutate(cycle_row = row_number()) %>%
  ungroup() %>%
  arrange(subject_id, dispo_date) %>%
  group_by(subject_id) %>%
  mutate(dispo_row = row_number()) %>%
  ungroup() %>%
  filter(cycle_row != dispo_row)

df %>%
  add_count(subject_id) %>%
  filter(n>1) %>%
  group_by(subject_id) %>%
  add_count(dispo_date) %>%
  ungroup() %>%
  filter(nn>1) %>%
  arrange(subject_id)

rm(d2)
```


Standardize factors
```{r}
df <- df %>%
 mutate(gender = as.factor(gender),
         
         # make age a number
         age = as.integer(age),
         age_first_dispo = as.integer(age_first_dispo),
        
         # add age category column
         age_cat = as.factor(case_when(
           age < 18 ~ "Under 18",
           age >= 18 & age <= 19 ~ "18-19 yrs",
           age > 19 & age <= 29 ~ "20-29 yrs",
           age > 29 & age <= 39 ~ "30-39 yrs",
           age > 39 & age <= 49 ~ "40-49 yrs",
           age > 49 & age <= 59 ~ "50-59 yrs",
           TRUE ~ "60+ yrs"
         )),
         
         
         # recode variables
         race = as.factor(case_when(
           race_code == "B" ~ "Black",
           race_code == "H" ~ "Hispanic",
           race_code == "W" ~ "White",
           race_code %in% c("A", "C", "D", "F", "G", "J", "K", "L", "P", "S", "U", "V", "Z") ~ "Asian/PI",
           race_code == "I" ~ "American Indian",
           T ~ "Other/Unknown")),
        
        # create a categorical variable for arrest offense type based only on felony arrest charges, prioritizing violent, then property, then drug
        arrest_f_offense_type = case_when(arrest_summ_f_violent_flag ==1 ~ "Violent",
                                         arrest_summ_f_property_flag == 1 ~ "Property",
                                         arrest_summ_f_drug_flag == 1 ~ "Drug",
                                         T ~ "Other"),
        
        #create combined suspended flag
        sent_suspended_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag ==1, 1, 0),
        
        #create a variable to track number of days since last dispo (will change to conviction when re-collapse completes)
        #think about what to do for ppl with no priors
        days_since_last_dispo = as.integer(dispo_date - prior_dispo_date), 
         
        #create scaled variables for hierarchy
        prior_max_conv_hier_scaled = scale(prior_max_conv_hier),
        max_arrest_hier_scaled = scale(max_arrest_hier),
        max_court_hier_scaled = scale(max_court_hier),
        max_conv_hier_scaled = scale(max_conv_hier),
        
        #calculate difference in hierarchy values from arrest to filing to conviction, and scale differences
        filing_reduction_scaled = scale(max_court_hier - max_arrest_hier, center = F),
        conv_reduction_scaled = scale(max_conv_hier - max_court_hier, center = F)
        
        )
```

Numbers for Figure 1 flow chart
```{r}
df %>%
  count(court_disp) %>%
  mutate(percent = n/sum(n)) #final court dispositions vs law enforcement/prosecution release dispositions

df %>%
  filter(court_disp ==1) %>%
  count(convicted_flag) %>%
  mutate(percent = n/sum(n)) #convicted out of those with a court disposition

df %>%
  filter(convicted_flag ==1) %>%
  count(sent_prison_flag) %>%
  mutate(percent = n/sum(n)) #prison sentences out of those convicted

df %>%
  filter(convicted_flag ==1) %>%
  count(sent_prison_flag, sent_jail_flag, sent_probation_flag) %>%
  mutate(percent = n/sum(n)) #jail and probation sentences out of those convicted


```

Demographics of felony defendants (court disposition)
```{r}
df %>%
  filter(court_disp ==1) %>%
  count(age_cat) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #age distribution by age category

df %>%
  filter(court_disp ==1) %>%
  count(gender) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #gender distribution

df %>%
  filter(court_disp ==1) %>%
  count(race) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #race distribution

```

Prior record of felony defendants (court disposition)
```{r}
df %>%
  filter(court_disp ==1) %>%
  count(prior_sent_prison_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) # prior prison

df %>%
  filter(court_disp ==1) %>%
  count(prior_sent_prison_flag_count == 0 & prior_sent_jail_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #prior jail with no prior prison

df %>%
  filter(court_disp ==1) %>%
  count(prior_sent_prison_flag_count == 0 & prior_sent_jail_flag_count == 0 & prior_sent_probation_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #prior probation with no prior incarceration

df %>%
  filter(court_disp ==1) %>%
  count(prior_sent_prison_flag_count == 0 & prior_sent_jail_flag_count == 0 & prior_convicted_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #prior conviction with no prior incarceration

df %>%
  filter(court_disp ==1) %>%
  count(prior_convicted_flag_count ==0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #no prior convictions

df %>%
  filter(court_disp ==1) %>%
  count(prior_conviction_felony_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) # has prior felony convictions

df %>%
  filter(court_disp ==1) %>%
  count(prior_conviction_felony_flag_count == 0 & prior_conviction_misd_flag_count >0) %>%
  mutate(percent = round(n/sum(n)*100, 1)) # has prior misdemeanors with no prior felonies

df %>%
  filter(court_disp ==1) %>%
  count(prior_conviction_felony_flag_count) %>%
  mutate(percent = round(n/sum(n)*100, 1)) # number of prior felony convictions

df %>%
  filter(court_disp ==1) %>%
  count(prior_conviction_misd_flag_count) %>%
  mutate(percent = round(n/sum(n)*100, 1)) # number of prior misdo convictions

mean(df$prior_conviction_felony_flag_count) #mean prior felonies
mean(df$prior_conviction_misd_flag_count) #mean prior misdos


df %>%
  filter(court_disp == 1) %>%
  mutate(prior_record_cat = case_when(prior_sent_prison_flag_count >0  ~ "Prior prison",
                                      prior_sent_jail_flag_count >0 & days_prior_jail >=365 ~ "Prior jail, 1 year or more",
                                      prior_sent_jail_flag_count >0  ~ "Prior jail, less than 1 year",
                                      prior_convicted_flag_count >0 ~ "Prior conviction with no prior incarceration",
                                      T ~ "No prior convictions")) %>%
  count(prior_record_cat) %>%
  mutate(percent = round(n/sum(n)*100, 1))


df %>%
  filter(prior_sent_prison_flag_count >0) %>%
  summarise(mean(days_prior_prison, na.rm = T)) #mean prior prison time is nearly 8 years, ouch.
  # count(is.na(days_prior_prison)) %>%
  # mutate(percent = round(n/sum(n)*100, 1))

df %>%
  filter(prior_sent_jail_flag_count >0) %>%
  summarise(mean(days_prior_jail, na.rm = T)) # mean prior jail time is a little less than 2 years.
  # count(is.na(days_prior_jail)) %>%
  # mutate(percent = round(n/sum(n)*100, 1))
```

Arrest offense type for felony defendants (court dispo)
```{r}

df %>%
  filter(court_disp ==1) %>%
  count(arrest_f_offense_type) %>%
  mutate(percent = round(n/sum(n)*100, 1)) #arrest offense type for felony arrest offenses only


# df %>%
#   filter(court_disp ==1) %>%
#   count(arrest_summ_f_violent_flag, arrest_summ_f_property_flag, arrest_summ_f_drug_flag, arrest_summ_f_other_sex_flag, arrest_summ_f_other_flag) %>%
#   mutate(percent = round(n/sum(n)*100, 1)) %>%
#   arrange(desc(n))
# 
# df %>%
#   filter(court_disp ==1) %>%
#   mutate(arrest_offense_type = case_when(arrest_summ_f_violent_flag ==1 ~ "Violent",
#                                          arrest_summ_f_property_flag == 1 ~ "Property",
#                                          arrest_summ_f_drug_flag == 1 ~ "Drug",
#                                          T ~ "Other")) %>%
#   count(arrest_offense_type) %>%
#   mutate(percent = round(n/sum(n)*100, 1)) #arrest offense type for felony arrest offenses only. prioritizing violent, then property, then drug, then other (could also show other sex, but percent is low, 1.8%, so lumped in with other)
# 
# 
# df %>%
#   filter(court_disp ==1) %>%
#   mutate(arrest_offense_type = case_when(arrest_summ_f_violent_flag ==1 | arrest_summ_m_violent_flag ~ "Violent",
#                                          arrest_summ_f_property_flag == 1 | arrest_summ_m_property_flag ~ "Property",
#                                          arrest_summ_f_drug_flag == 1 | arrest_summ_m_drug_flag ~ "Drug",
#                                          T ~ "Other")) %>%
#   count(arrest_offense_type) %>%
#   mutate(percent = round(n/sum(n)*100, 1)) #arrest offense type for all arrest offenses, including misdo charges. prioritizing violent (felony or misdo), then property (felony or misdo), then drug (felony or misdo), then other


```

Descriptive info on sentences
```{r}
df %>%
  filter(sent_prison_flag ==1) %>%
  summarise(mean(prison_length_days, na.rm = T)) #mean prison sentence term is 2039 days (5.6 years)

df %>%
  filter(sent_jail_flag == 1) %>%
  summarise(mean(jail_length_days, na.rm = T)) #mean jail sentence term is 272 days (0.75 years)

df %>%
  filter(sent_probation_flag == 1) %>%
  count(probation_length_days)
  summarise(mean(probation_length_days, na.rm = T)) #mean probation sentence term is 1242 days (3.4 years). this might be thrown off by suspended sentences that lack probation length (many of these are zeros), and some wonky extremely large term lengths (there is one over 100,000 days = 273 years.... seems excessive)


```

Descriptive info on offenses and priors by race and age category
```{r}
aggregate(cyc_age ~ race, data = df, FUN = mean)

aggregate(age_cat ~ race, data = df, count)

#priors by race
df %>%
  group_by(race) %>%
  summarise(n = n(), mean_age = mean(cyc_age), mean_prior_fs = mean(prior_conviction_felony_flag_count), mean_prior_ms = mean(prior_conviction_misd_flag_count))

df %>%
  group_by(age_cat) %>%
  summarise(n = n(), mean_prior_fs = mean(prior_conviction_felony_flag_count), mean_prior_ms = mean(prior_conviction_misd_flag_count))

#offense categories by race
df %>%
  group_by(race) %>%
  summarise(violentf = mean(arrest_f_offense_type == "Violent"), propf = mean(arrest_f_offense_type == "Property"), drugf = mean(arrest_f_offense_type == "Drug"), otherf = mean(arrest_f_offense_type == "Other"))

#offense categories by age category
df %>%
  group_by(age_cat) %>%
  summarise(violentf = mean(arrest_f_offense_type == "Violent"), propf = mean(arrest_f_offense_type == "Property"), drugf = mean(arrest_f_offense_type == "Drug"), otherf = mean(arrest_f_offense_type == "Other"))

#prior offense category counts by race
df %>%
  group_by(race) %>%
  summarise(prior_violentf = mean(prior_arrest_summ_f_violent_flag_count), prior_propf = mean(prior_arrest_summ_f_property_flag_count), prior_drugf = mean(prior_arrest_summ_f_drug_flag_count), prior_otherf = mean(prior_arrest_summ_f_other_flag_count))


#number of arrest charges and offense hierarchy by race
df %>%
  group_by(race) %>%
  summarise(fcharge = mean(arrested_fcharge_count), mcharge = mean(arrested_mcharge_count), arresthier = mean(max_arrest_hier))

#number of filed charges and offense hierarchy by race
df %>%
  group_by(race) %>%
  summarise(ffiled = mean(filed_fcharge_count), mfiled = mean(filed_mcharge_count), filedhier = mean(max_court_hier))

#number of convicted charges and offense hierarchy by race
df %>%
  group_by(race) %>%
  summarise(fconv = mean(convicted_fcharge_count), mconv = mean(convicted_mcharge_count), convhier = mean(max_conv_hier))

#average drop in hierarchy from arrest to filing for those filed by race
df %>%
  filter(filed_flag == 1) %>%
  group_by(race) %>%
  summarise(arrest_to_filing_drop = mean(max_court_hier - max_arrest_hier))

#average drop in hierarchy from filing to conviction for those convicted by race
df %>%
  filter(convicted_flag == 1) %>%
  group_by(race) %>%
  summarise(filing_to_conviction_drop = mean(max_conv_hier- max_court_hier))

#filing rate and overall conviction rate out of all arrests by race
df %>%
  group_by(race) %>%
  summarise(filing = mean(filed_flag), convictions_all = mean(convicted_flag))

#conviction rate out of cases filed by race
df %>%
  filter(filed_flag == 1) %>%
  group_by(race) %>%
  summarise(filed_conviction = mean(convicted_flag))

#prison sentencing rate out of convicted cases by race
df %>%
  filter(convicted_flag == 1) %>%
  group_by(race) %>%
  summarise(prison = mean(sent_prison_flag))

#jail sentencing rate out of convicted cases not sentenced to prison by race
df %>%
  filter(convicted_flag == 1, sent_prison_flag == 0) %>%
  group_by(race) %>%
  summarise(jail = mean(sent_jail_flag))

#prison sentence length out of cases sentenced to prison
df %>%
  filter(sent_prison_flag == 1) %>%
  group_by(race) %>%
  summarise(prison_length = mean(prison_length_days, na.rm = T), length_na = mean(is.na(prison_length_days)))

#jail sentence length out of cases sentenced to jail
df %>%
  filter(sent_jail_flag == 1) %>%
  group_by(race) %>%
  summarise(jail_length = mean(jail_length_days, na.rm = T), length_na = mean(is.na(jail_length_days)))

#probation sentence length out of cases sentenced to probation
df %>%
  filter(sent_probation_flag == 1) %>%
  group_by(race) %>%
  summarise(prob_length = mean(probation_length_days, na.rm = T), length_na = mean(is.na(probation_length_days)))

df %>%
  select(arrest_f_offense_type)
```

Tables for Appendix D
```{r}
ggplot(df, aes(fill=race, y= mean(convicted_flag), x=arrest_f_offense_type)) + 
    geom_bar(position="dodge", stat="identity") +
    scale_color_brewer(palette = "Set1") #+
    #ggtitle("Conviction rate") +
    #facet_wrap(~arrest_f_offense_type) +
    #theme(legend.position="none") +
    #xlab("")

#Conviction rate by race
df %>%
  filter(race %in% c("Black", "White", "Hispanic", "Asian/PI")) %>%
  group_by(race) %>%
  summarise(mean(convicted_flag)) %>%
  rename(conviction_rate = 'mean(convicted_flag)') %>%
  ggplot(aes(fill=race, y= conviction_rate, x=race)) + 
    geom_bar(position="dodge", stat="identity") +
    scale_color_brewer(palette = "Set1")

df %>%
  filter(race %in% c("Black", "White", "Hispanic", "Asian/PI")) %>%
  filter(arrest_f_offense_type %in% c("Drug", "Property", "Violent")) %>%
  group_by(race, arrest_f_offense_type) %>%
  summarise(mean(convicted_flag)) %>%
  rename(conviction_rate = 'mean(convicted_flag)') %>%
  ggplot(aes(fill=race, y= conviction_rate, x=arrest_f_offense_type)) + 
    geom_bar(position="dodge", stat="identity") +
    scale_color_brewer(palette = "Set1")

```



Set desired base levels
```{r}
df$race <- relevel(df$race, ref="White")
df$gender <- relevel(df$gender, ref="M")
df$arrest_f_offense_type <- as.factor(df$arrest_f_offense_type)
df$arrest_f_offense_type <- relevel(df$arrest_f_offense_type, ref="Property")
df$county <- as.factor(df$county)
df$county <- relevel(df$county, ref ="LOS ANGELES")
```

Filed regressions
```{r}

#no county
filed <- glm(filed_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + arrest_f_offense_type + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + age + gender +race, data = df, family = 'poisson')

# summary(conv_county)
filed <- tidy(coeftest(filed, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

filed



```


Create function to get McFadden Pseudo R2 values for each variable in a regression
```{r}

mcfaddenpr2 <- function(d, dv, ivs){
  df <- d
  test_df <- lapply(c(1:nrow(ivs)), function(i){
    test <- ivs %>%
      slice(-i) %>%
      mutate(missing = ivs$variable[i])
    return(test)
  }) %>% bind_rows %>%
    bind_rows(ivs %>% mutate(missing = "full"))
  
  eqn_test <- lapply(c(1:length(unique(test_df$missing))), function(i){
    vars <- unique(test_df$missing)
    missing_var <- vars[i]
    test <- test_df %>%
      filter(missing == missing_var) %>%
      select(variable)
    
    str_lst <- ""
    for(i in c(1:nrow(test))){
      
      str_lst <- if_else(str_lst == "", paste0(test$variable[i]), paste0(str_lst, " + ", test$variable[i]))
      }
    
    fun_str <- paste0("glm(", dv, " ~ ", str_lst, ", data = df, family = 'poisson')")
    

    test_mod <- eval(parse(text = fun_str))
    test_pr2 <- as.tibble(pR2(test_mod)[4])%>%
              mutate(model = missing_var)
    return(test_pr2)
  }) %>%
    bind_rows() %>%
    mutate(difference = value[model == "full"] - value)
  return(eqn_test)
}
```

Diagnostic code
```{r}
#use pseudo r2 function to look at all pseudo r2 values for given dv and ivs (assuming glm with family = 'poisson')
dv <- "filed_flag"
ivs <- tibble(variable = c("arrest_f_offense_type", "race", "gender"))

test <- mcfaddenpr2(df, dv, ivs)

#####

#extract mcfadden pseudo-r2 values

r2s <- as.tibble(pR2(filed)[4]) %>%
  mutate(model = "full")

r2s <- as.tibble(pR2(glm(filed_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + arrest_f_offense_type + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + age + gender, data = df, family = 'poisson'))[4]) %>%
            mutate(model = "minus race") %>%
            bind_rows(r2s)

r2s <- as.tibble(pR2(glm(filed_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + arrest_f_offense_type + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + age + race, data = df, family = 'poisson'))[4]) %>%
            mutate(model = "minus gender") %>%
            bind_rows(r2s)

r2s <- r2s %>%
  mutate(difference = value[model == "full"] - value)

full_model = glm(filed_flag ~ arrest_f_offense_type + race + gender, data = df, family = 'poisson')

# r2s <- as.tibble(pR2(full_model)[4]) %>%
#   mutate(model = "full")

# tidy(coeftest(full_model, vcov. = sandwich))

    #test_mod <- glm(filed_flag ~ get(test$variable[1]) + get(test$variable[2]), data = df, family = 'poisson')

test = "glm(filed_flag ~ arrest_f_offense_type + race + gender, data = df, family = 'poisson')"
eval(parse(text = test))

is.na(blah)

test = ""
for(i in c(1:3)){
  test <- if_else(test == "", paste0(i), paste0(test, " + ", i))
}

test <- tibble(x = c(1, 1, 2, 4, 4, 5, 6), y = c(1, 1, 1, 1, 1, 1, 1))
unique(test$x)
str(test)
```


Conviction regressions
```{r}

#no county
conv <- glm(convicted_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + arrest_f_offense_type + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + age + gender +race, data = subset(df, filed_flag == 1), family = 'poisson')

#filed rather than arrest charges
conv <- glm(convicted_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + court_summ_f_violent_flag + court_summ_f_property_flag + court_summ_f_drug_flag + court_sex_flag + court_dv_flag + filed_mcharge_count + filed_fcharge_count + age + gender +race, data = subset(df, filed_flag == 1), family = 'poisson')

#with county
conv <- glm(convicted_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + scale(prior_max_conv_hier) + arrest_sup_vio_flag + court_summ_f_violent_flag + court_summ_f_property_flag + court_summ_f_drug_flag + court_sex_flag + court_dv_flag + filed_mcharge_count + filed_fcharge_count + scale(max_court_hier) + age + gender +race + county, data = subset(df, filed_flag == 1), family = 'poisson')

dftest <- df %>%
  mutate(days_since_last_dispo = as.integer(dispo_date - prior_dispo_date), #think about what to do for ppl with no priors
         prior_max_conv_hier_scaled = scale(prior_max_conv_hier),
         max_arrest_hier_scaled = scale(max_arrest_hier),
         max_court_hier_scaled = scale(max_court_hier),
         max_conv_hier_scaled = scale(max_conv_hier),
         filing_reduction_scaled = scale(max_court_hier - max_arrest_hier, center = F),
         conv_reduction_scaled = scale(max_conv_hier - max_court_hier, center = F))

#look at days since last dispo, except would need to correct for when they have no priors
conv <- glm(convicted_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + prior_max_conv_hier_scaled + arrest_sup_vio_flag + court_summ_f_violent_flag + court_summ_f_property_flag + court_summ_f_drug_flag + court_sex_flag + court_dv_flag + filed_mcharge_count + filed_fcharge_count + max_court_hier_scaled + age + gender +race + county + days_since_last_dispo, data = subset(df, filed_flag == 1), family = 'poisson')

# summary(conv_county)
conv <- tidy(coeftest(conv, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

conv

dftest %>%
  select(filing_reduction_perc, conv_reduction_perc, filing_reduction_scaled, conv_reduction_scaled)

```

Charge reduction regressions
```{r}
file_reduc <- lm(filing_reduction_scaled ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + prior_max_conv_hier_scaled + arrest_sup_vio_flag + arrest_summ_f_violent_flag + arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + max_arrest_hier_scaled + age + gender +race + county + days_since_last_dispo, data = subset(df, filed_flag == 1))

summary(file_reduc)

conv_reduc <- lm(conv_reduction_scaled ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + prior_max_conv_hier_scaled + arrest_sup_vio_flag + court_summ_f_violent_flag + court_summ_f_property_flag + court_summ_f_drug_flag + court_sex_flag + court_dv_flag + filed_mcharge_count + filed_fcharge_count + max_court_hier_scaled + age + gender +race + county + days_since_last_dispo, data = subset(df, convicted_flag == 1))

summary(conv_reduc)

#these are looking at just the ones that were filed/convicted, the amount of reduction. could also look at all and figure out how to set the reduction to appropriately account for fully dismissed/dropped charges.

#try creating transformed variables
dftest <- df %>%
  mutate(max_court_transformed = 1/log(max_court_hier),
         max_arrest_transformed = 1/log(max_arrest_hier),
         max_conv_transformed = 1/log(max_conv_hier),
         filing_reduction = if_else(filed_flag == 1, (max_arrest_transformed - max_court_transformed)*1000, max_arrest_transformed*1000),
         conv_reduction = if_else(convicted_flag == 1, (max_court_transformed - max_conv_transformed)*1000, max_court_transformed*1000))

file_reduc <- lm(filing_reduction ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + prior_max_conv_hier_scaled + arrest_sup_vio_flag + arrest_summ_f_violent_flag + arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + max_arrest_hier_scaled + age + gender +race + county + days_since_last_dispo, data = dftest)

summary(file_reduc)

conv_reduc <- lm(conv_reduction ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + prior_max_conv_hier_scaled + arrest_sup_vio_flag + court_summ_f_violent_flag + court_summ_f_property_flag + court_summ_f_drug_flag + court_sex_flag + court_dv_flag + filed_mcharge_count + filed_fcharge_count + max_court_hier_scaled + age + gender +race + county + days_since_last_dispo, data = dftest)

summary(conv_reduc)


```

Felony conviction regressions
```{r}
#conviction regression, kitchen sink
conv_fel <- glm(conviction_felony_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + arrest_f_offense_type + arrest_sex_flag + arrest_dv_flag + arrested_mcharge_count + arrested_fcharge_count + age + gender +race, data = subset(df, convicted_flag == 1), family = 'poisson')

# summary(conv_county)
felcon <- tidy(coeftest(conv_fel, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

felcon

df$arrested_mcharge_count
```

Prison sentencing regressions
```{r}
#prison sentence regression, kitchen sink
prison_county <- glm(sent_prison_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender +race + stp_ori_cnty_name, data = subset(df, convicted_flag == 1), family = 'poisson')

#without county
prison_sent <- glm(sent_prison_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + age + gender +race, data = subset(df, convicted_flag == 1 & conviction_felony_flag == 1), family = 'poisson')

#same as above but without race
prison_norace <- glm(sent_prison_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender, data = subset(df, convicted_flag == 1), family = 'poisson')

#non-binary
# prison_county <- lm(sent_prison_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender +race + stp_ori_cnty_name, data = subset(df, convicted_flag == 1))


#summary(prison_county)

pris_sent <- tidy(coeftest(prison_sent, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

pris_sent

# likelihood ratio test to compare models with and without race
model_comp <- tidy(lrtest(prison_norace, prison_sent))

df$conviction_felony_flag
```

Prison sentence length regressions
```{r}
#prison sentence length regression, kitchen sink

prison_length <- lm(prison_length_days ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count  + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag  + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender  + stp_ori_cnty_name + race, data = subset(df, sent_prison_flag == 1))

#without county
prison_length <- lm(prison_length_days ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count  + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag  + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender  + race, data = subset(df, sent_prison_flag == 1))

#without race
prison_length_norace <- lm(prison_length_days ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count  + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag  + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + cyc_age + gender, data = subset(df, sent_prison_flag == 1))

summary(prison_length)

lrtest(prison_length, prison_length_norace)
anova(prison_length, prison_length_norace)
#what is the difference between lrtest and anova? which is appropriate to use here?

#some weird very old cycle dates
df %>%
  filter(cyc_date < as_date("1990-01-01"))


```

Jail sentencing regressions
```{r}
#felony convictions only, with no prison sentence. without county.
jail_sent <- glm(sent_jail_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + age + gender +race, data = subset(df, convicted_flag == 1 & sent_prison_flag == 0 & conviction_felony_flag == 1), family = 'poisson')

#misdo convictions only
jail_sent <- glm(sent_jail_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_m_violent_flag + conviction_summ_m_property_flag + conviction_summ_m_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_mcharge_count + max_conv_hier + age + gender +race + county, data = subset(df, convicted_flag == 1 & sent_prison_flag == 0 & conviction_felony_flag == 0), family = 'poisson')

#misdo convictions only, without county
jail_nocounty <- glm(sent_jail_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_m_violent_flag + conviction_summ_m_property_flag + conviction_summ_m_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_mcharge_count + max_conv_hier + age + gender +race, data = subset(df, convicted_flag == 1 & sent_prison_flag == 0 & conviction_felony_flag == 0), family = 'poisson')

jailed <- tidy(coeftest(jail_sent, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

jailed

lrtest(jail_nocounty, jail_sent)

subset(df, convicted_flag == 1 & sent_prison_flag == 0 & conviction_felony_flag == 1) %>%
  count(sent_jail_flag, sent_probation_flag)

df %>%
  count(sent_jail_flag, sent_suspended_flag)
```
Jail length regressions
```{r}
#without county
jail_length <- lm(jail_length_days ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count  + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag  + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + age + gender  + race, data = subset(df, sent_prison_flag == 0 & sent_jail_flag == 1))

summary(jail_length)
```
Probation length regressions
```{r}
#without county
prob_length <- lm(probation_length_days ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count  + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag  + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + age + gender  + race, data = subset(df, sent_prison_flag == 0 & sent_jail_flag == 0 & sent_probation_flag ==1 & probation_length_days != 0))

summary(prob_length)
```
Sentence suspension regressions
```{r}
#without county
dftest <- df %>%
  mutate(suspended_flag = if_else(sent_ex_suspended_flag == 1 | sent_imp_suspended_flag ==1, 1, 0)) %>%
  filter(convicted_flag == 1 & sent_prison_flag == 0 & (sent_jail_flag == 1 | suspended_flag == 1)) 


sent_susp <- glm(suspended_flag ~  prior_conviction_felony_flag_count + prior_conviction_misd_flag_count + conviction_summ_f_violent_flag + conviction_summ_f_property_flag + conviction_summ_f_drug_flag + conviction_sex_flag + conviction_sup_vio_flag + convicted_fcharge_count + convicted_mcharge_count + max_conv_hier + age + gender +race, data = dftest, family = 'poisson')

suspended <- tidy(coeftest(sent_susp, vcov. = sandwich)) %>%
  mutate(relative_risk = round(exp(estimate), 4))

suspended
```

Diagnostics
```{r}
dispos %>%
  select(prior_quals) %>%
  separate_rows(prior_quals) %>%
  count(prior_quals) %>%
  arrange(desc(n))

dispos %>%
  count(arrest_disp, court_disp)
#some have both arrest and court dispos... what does this mean? perhaps some charges dropped before filing but not all?

dispos %>%
  count(court_disp) %>%
  mutate(percent = n/sum(n))

dispos %>%
  count(arrest_felony_flag)%>%
  mutate(percent = n/sum(n))
#why are not all of these felony arrests??? theoretically this whole dataset is felony arrests, and yet this shows only 64% are felonies

dispos %>%
  filter(filed_flag == 1) %>%
  count(court_felony_flag)%>%
  mutate(percent = n/sum(n))

dispos %>%
  filter(convicted_flag == 1) %>%
  count(conviction_felony_flag)%>%
  mutate(percent = n/sum(n))

dispos %>%
  count(filed_flag, convicted_flag)%>%
  mutate(percent = n/sum(n))

dispos %>%
  filter(prison_length_days >0) 
  # count(sent_jail_flag, sent_probation_flag)%>%
  # mutate(percent = n/sum(n))

dispos %>%
  distinct(subject_id) #93,478 unique people

dispos %>%
  count(subject_id) %>%
  arrange(desc(n)) #some people have as many as 46 dispositions in 2019..... ouch.

dispos %>%
  count(race_code) %>%
  mutate(percent = n/sum(n)) %>%
  arrange(desc(n))

dispos %>%
  count(prior_sent_prison_flag_count>0) %>%
  mutate(percent = n/sum(n))

dispos %>%
  mutate(test = arrest_summ_f_violent_flag + arrest_summ_f_property_flag + arrest_summ_f_drug_flag + arrest_summ_f_other_sex_flag + arrest_summ_f_other_flag) %>%
  count(test) %>%
  #count(arrest_summ_f_violent_flag, arrest_summ_f_property_flag, arrest_summ_f_drug_flag, arrest_summ_f_other_sex_flag, arrest_summ_f_other_flag)%>%
  mutate(percent = n/sum(n))

dispos %>%
  filter(arrest_felony_flag == 0)

dsam %>%
  count(disp_descr) %>%
  arrange(desc(n))

dsam %>%
  filter(disp_descr == "NO DISPOSITION INFORMATION AVAILABLE") %>%
  count(stp_type_descr)

test<- dispos %>%
  filter(arrest_felony_flag == 0) %>%
  select(subject_id, cyc_date)

dsam %>%
  semi_join(test) %>%
  distinct(subject_id, cyc_date)

df <- vroom("G:/CrimJustice/Dispositions by Race and Ethnicity/DOJ Data 2019/DALA_2019_JCC.csv",  col_types = c(.default = "c"))

df %>%
  count(`TYPE_OF_CHARGE`)

dispos %>%
  filter(arrest_felony_flag == 1) %>%
  count(court_disp)%>%
  mutate(perc = n/sum(n))

dispos %>%
  semi_join(test, by = "subject_id") %>%
  group_by(subject_id) %>%
  mutate(tot_f_arrests = sum(arrest_felony_flag)) %>%
  ungroup() %>%
  #distinct(subject_id, .keep_all = T) %>%
  filter(tot_f_arrests == 0)

df %>%
  count(RECORD_ID) %>%
  mutate(perc = n/sum(n))
```

